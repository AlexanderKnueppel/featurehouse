options {	DEBUG_PARSER=true;	LOOKAHEAD=3;	STATIC=false;}PARSER_BEGIN(QueryLanguageParser)package queryLanguageParser;import java.io.Reader;import java.io.StringReader;import java.util.List;import java.util.LinkedList;import java.util.regex.Pattern;import ast.FSTNode;import ast.FSTNonTerminal;public class QueryLanguageParser{	class NameTypePattern {		public final static int POSITION_NAME = 0;			public final static int POSITION_TYPE = 1;			String[] nameType = new String[2];			public NameTypePattern(String namePattern, String typePattern) {		    nameType[POSITION_NAME] = namePattern;		    nameType[POSITION_TYPE] = typePattern;		}			public String getPattern(int i) {		    return nameType[i];		}    }	/**    *     */	private FSTNode root = null;		/**	*	*/	private static final String JAVA_REGEX_PATTERN_WILDCARD = "(.)*";	/**	*	*/    private static final String QUOTATION_MARK = "\"";		/**    *     */    public List<FSTNode> parse() throws ParseException {		return expression();    }	/**    *     */    public QueryLanguageParser(String query, FSTNode root) {		this((Reader) (new StringReader(query)));		this.root=root;    }        /**    *     */    private List<FSTNode> minus(List<FSTNode> a, List<FSTNode> b) {	List<FSTNode> result = new LinkedList<FSTNode>(a);		result.removeAll(b);                        return result;           }    /**    *     */    private List<FSTNode> and(List<FSTNode> a, List<FSTNode> b) {		List<FSTNode> result = new LinkedList<FSTNode>(a);		result.retainAll(b);         return result;    }    /**    *     */    private List<FSTNode> or(List<FSTNode> a, List<FSTNode> b) {	List<FSTNode> result = new LinkedList<FSTNode>(a);		result.removeAll(b);		result.addAll(b);        return result;    }        /**     *      * @param tokenList     * @return     */    private List<FSTNode> getNodesForSingleTreeAddress(List<Token> tokenList) {		List<FSTNode> list = new LinkedList<FSTNode>();		list.add(root);		list = getNodesForSingleTreeAddressRecursive(list, tokenList);		return list;    }            /**    *     */    private List<FSTNode> getNodesForSingleTreeAddressRecursive(	    List<FSTNode> nodeList, List<Token> tokenList) {	List<FSTNode> list = new LinkedList<FSTNode>();	if (nodeList.isEmpty() || tokenList.isEmpty())	    return list;	List<Token> newShortenedTokenList = new LinkedList<Token>();	newShortenedTokenList.addAll(tokenList);	String namePattern = "";	String typePattern = "";	boolean reachedAdressDivider = false;	for (Token t : tokenList) {	    /*	     * address token is complete. Can now search among the nodeList for	     * matching name/type	     */	    if (t.kind == ADDRESS_DIVIDER) {		newShortenedTokenList.remove(t);		break;	    }	    else if (t.kind == TYPE_DIVIDER) {		reachedAdressDivider = true;		newShortenedTokenList.remove(t);	    }	    /*	     * concat wildcard to pattern	     */	    else if (t.kind == WILDCARD) {		if (!reachedAdressDivider) {		    namePattern = namePattern			    .concat(JAVA_REGEX_PATTERN_WILDCARD);		    newShortenedTokenList.remove(t);		} else {		    typePattern = typePattern			    .concat(JAVA_REGEX_PATTERN_WILDCARD);		    newShortenedTokenList.remove(t);		}	    }	    /*	     * concat word to pattern	     */	    else if (t.kind == WORD) {		if (!reachedAdressDivider) {		    namePattern = namePattern.concat(t.toString().replaceAll(			    (tokenImage[SPECIAL_CHARACTER_FLAG].replaceAll(				    QUOTATION_MARK, "")), ""));		    newShortenedTokenList.remove(t);		} else {		    typePattern = typePattern.concat(t.toString().replaceAll(			    (tokenImage[SPECIAL_CHARACTER_FLAG].replaceAll(				    QUOTATION_MARK, "")), ""));		    newShortenedTokenList.remove(t);		}	    }	}	for (FSTNode node : nodeList) {	    if (Pattern.matches(namePattern, node.getName())		    && Pattern.matches(typePattern, node.getType())) {		if (newShortenedTokenList.isEmpty())		    list.add(node);		else if (node.getClass() == FSTNonTerminal.class) {		    list.addAll(getNodesForSingleTreeAddressRecursive(			    ((FSTNonTerminal) node).getChildren(),			    newShortenedTokenList));		}	    }	}		return list;    }}PARSER_END(QueryLanguageParser)SKIP:{	" "	| "\t"	| "\n"	| "\r"}TOKEN:{<SPECIAL_CHARACTER_FLAG: "'">| <SPECIAL_CHARACTER:	<SPECIAL_CHARACTER_FLAG>	("||"	| "&&"	| "-"	| "."	| ":"	| "*"	| "("	| ")"	)>}		TOKEN:{	<UNION:"||">	| <INTERSECTION:"&&">	| <MINUS:"-">	| <ADDRESS_DIVIDER:".">	| <TYPE_DIVIDER:":">	| <WILDCARD:"*">	| <LEFT_BRACE:"(">	| <RIGHT_BRACE:")">}TOKEN:{	<#NUMBER:["0"-"9"]>	| <#SMALL_CHARACTER:["a"-"z"]>	| <#GREAT_CHARACTER:["A"-"Z"]>	| <WORD:(<SMALL_CHARACTER>		| <GREAT_CHARACTER>		| <NUMBER>		| <SPECIAL_CHARACTER>	)+>}  /*** independent expression*/
List<FSTNode> expression():{	List<FSTNode> nodeListOp1 = new LinkedList<FSTNode>();	List<FSTNode> nodeListOp2 = new LinkedList<FSTNode>();	List<FSTNode> nodeListRes = new LinkedList<FSTNode>();}{	nodeListOp1 = queryTerm() {		nodeListRes = nodeListOp1;	} (		//union operator		(<UNION> nodeListOp2 = queryTerm() {			nodeListRes = nodeListOp1 = or(nodeListOp1, nodeListOp2);					}		| <INTERSECTION> nodeListOp2 = queryTerm()  {			nodeListRes = nodeListOp1 = and(nodeListOp1, nodeListOp2);		}		| <MINUS> nodeListOp2 = queryTerm() {			nodeListRes = nodeListOp1 = minus(nodeListOp1, nodeListOp2);		}		)	)* {		return nodeListRes;	}}/*** query term without operators outside braces*/List<FSTNode> queryTerm():{	List<FSTNode> nodeList = new LinkedList<FSTNode>();	List<Token> tokenList = new LinkedList<Token>();}{	((<LEFT_BRACE> nodeList = expression() <RIGHT_BRACE>) {		return nodeList;	}	| tokenList = treeAddress()) {		return getNodesForSingleTreeAddress(tokenList);	}}/*** single tree address without operators*/List<Token> treeAddress():{	List<Token> tokenList = new LinkedList<Token>();	List<Token> tempTokenList = new LinkedList<Token>();	Token t;}{	tempTokenList = treeAddressToken() {		tokenList.addAll(tempTokenList);	}	(t = <ADDRESS_DIVIDER> {		tokenList.add(t);	} tempTokenList = treeAddressToken() {		tokenList.addAll(tempTokenList);	})* {		return tokenList;	}}/*** tokens split by <ADDRESS_DIVIDER>*/List<Token> treeAddressToken():{	List<Token> tokenList = new LinkedList<Token>();	List<Token> tempTokenList = new LinkedList<Token>();	Token t;}{	tempTokenList = name() {		tokenList.addAll(tempTokenList);	} t = <TYPE_DIVIDER> {		tokenList.add(t);	} tempTokenList = type() {		tokenList.addAll(tempTokenList);			} {		return tokenList;	}}/*** name of AddressToken()*/List<Token> name():{	List<Token> tokenList = new LinkedList<Token>();}{	tokenList = stringWithWildcards() {		return tokenList;	}}/*** type of AddressToken()*/List<Token> type():{	List<Token> tokenList = new LinkedList<Token>();}{	tokenList = stringWithWildcards() {		return tokenList;	}}/*** forming a string that contains any number of wildcards.* restriction: no wildcards follow each other straightly.*/List<Token> stringWithWildcards():{	List<Token> tokenList = new LinkedList<Token>();	Token t;}{	(	(t = <WILDCARD>		{tokenList.add(t);}		(t = <WORD>		{tokenList.add(t);}		t = <WILDCARD>		{tokenList.add(t);}		)*		(t = <WORD>		{tokenList.add(t);}		)?)		| 		(t = <WORD>		{tokenList.add(t);}		(t = <WILDCARD>		{tokenList.add(t);}		t = <WORD>		{tokenList.add(t);}		)*		(t = <WILDCARD>		{tokenList.add(t);}		)?)	)		{return tokenList;}}