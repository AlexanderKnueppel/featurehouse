options {	DEBUG_PARSER=true;	LOOKAHEAD=5;	STATIC=false;}PARSER_BEGIN(QueryLanguageParser)package modification.queryLanguageParser;import java.io.Reader;import java.io.StringReader;import java.util.List;import java.util.LinkedList;import java.util.regex.Pattern;import de.ovgu.cide.fstgen.ast.FSTNode;import de.ovgu.cide.fstgen.ast.FSTNonTerminal;public class QueryLanguageParser{	/**    *     */	private FSTNode root = null;		/**	*	*/	private static final String JAVA_REGEX_PATTERN_STRING_WILDCARD = "(.)*";	/**	*	*/    private static final String QUOTATION_MARK = "\"";		/**    *     */    public List<FSTNode> parse() throws ParseException {		return expression();    }	/**    *     */    public QueryLanguageParser(String query, FSTNode root) {		this((Reader) (new StringReader(query)));		this.root=root;    }        /**    *     */    private List<FSTNode> minus(List<FSTNode> a, List<FSTNode> b) {	List<FSTNode> result = new LinkedList<FSTNode>(a);		result.removeAll(b);                        return result;           }    /**    *     */    private List<FSTNode> and(List<FSTNode> a, List<FSTNode> b) {		List<FSTNode> result = new LinkedList<FSTNode>(a);		result.retainAll(b);         return result;    }    /**    *     */    private List<FSTNode> or(List<FSTNode> a, List<FSTNode> b) {	List<FSTNode> result = new LinkedList<FSTNode>(a);		result.removeAll(b);		result.addAll(b);        return result;    }}PARSER_END(QueryLanguageParser)SKIP:{	" "	| "\t"	| "\n"	| "\r"}TOKEN:{<SPECIAL_CHARACTER_FLAG: "'">| <SPECIAL_CHARACTER:	<SPECIAL_CHARACTER_FLAG>	("||"	| "&&"	| "-"	| "."	| ":"	| "*"	| "("	| ")"	)>}		TOKEN:{	<UNION:"||">	| <INTERSECTION:"&&">	| <MINUS:"-">	| <ADDRESS_DIVIDER:".">	| <TYPE_DIVIDER:":">	| <ADDRESS_WILDCARD:"..">	| <STRING_WILDCARD:"*">	| <LEFT_BRACE:"(">	| <RIGHT_BRACE:")">}TOKEN:{	<#NUMBER:["0"-"9"]>	| <#SMALL_CHARACTER:["a"-"z"]>	| <#GREAT_CHARACTER:["A"-"Z"]>	| <WORD:(<SMALL_CHARACTER>		| <GREAT_CHARACTER>		| <NUMBER>		| <SPECIAL_CHARACTER>	)+>}  /*** independent expression*/
List<FSTNode> expression():{	List<FSTNode> nodeListOp1 = new LinkedList<FSTNode>();	List<FSTNode> nodeListOp2 = new LinkedList<FSTNode>();	List<FSTNode> nodeListRes = new LinkedList<FSTNode>();}{	nodeListOp1 = queryTerm() {		nodeListRes = nodeListOp1;	} (		//union operator		(<UNION> nodeListOp2 = queryTerm() {			nodeListRes = nodeListOp1 = or(nodeListOp1, nodeListOp2);					}		| <INTERSECTION> nodeListOp2 = queryTerm()  {			nodeListRes = nodeListOp1 = and(nodeListOp1, nodeListOp2);		}		| <MINUS> nodeListOp2 = queryTerm() {			nodeListRes = nodeListOp1 = minus(nodeListOp1, nodeListOp2);		}		)	)* {		return nodeListRes;	}}/*** query term without operators outside braces*/List<FSTNode> queryTerm():{	List<FSTNode> nodeList;	TreeAddress treeAddress;}{	((<LEFT_BRACE> nodeList = expression() <RIGHT_BRACE>) {		return nodeList;	}	| treeAddress = treeAddress()) {		return treeAddress.resolve(root);	}}/*** single tree address without operators*/TreeAddress treeAddress():{	List<TreeAddressToken> tokenList = new LinkedList<TreeAddressToken>();	List<TreeAddressToken> tempTokenList;}{			(		tempTokenList = literalAddress() 		{tokenList.addAll(tempTokenList);}					(			<ADDRESS_WILDCARD> 			{tokenList.add(new WildcardToken());}						tempTokenList = literalAddress() 			{tokenList.addAll(tempTokenList);}						)*	)						| 				(		<ADDRESS_WILDCARD>		{tokenList.add(new WildcardToken());}						(			tempTokenList = literalAddress() 			{tokenList.addAll(tempTokenList);}						<ADDRESS_WILDCARD> 			{tokenList.add(new WildcardToken());}						)*							(tempTokenList = literalAddress() 			{tokenList.addAll(tempTokenList);}		)		)	{return new TreeAddress(tokenList);}}/*** */List<TreeAddressToken> literalAddress():{	List<TreeAddressToken> tokenList = new LinkedList<TreeAddressToken>();	TreeAddressToken token;}{	token = nameTypePatternToken()	{tokenList.add(token);}		(		<ADDRESS_DIVIDER>				token = nameTypePatternToken() 		{tokenList.add(token);}	)*		{return tokenList;}}/*** tokens split by <ADDRESS_DIVIDER>*/TreeAddressToken nameTypePatternToken():{	String name;	String type;}{	name = name()	<TYPE_DIVIDER>	type = type() {		return new NameTypePatternToken(name,type);	}}/*** */String name():{	String name;}{	name = stringWithWildcards() {		return name;	}}/*** */String type():{	String type;}{	type = stringWithWildcards() {		return type;	}	}/*** */String stringWithWildcards():{	String s = "";	Token t;}{	(	(<STRING_WILDCARD>		{s = s.concat(JAVA_REGEX_PATTERN_STRING_WILDCARD);}		(t = <WORD>		{s = s.concat(t.toString());}		<STRING_WILDCARD>		{s = s.concat(JAVA_REGEX_PATTERN_STRING_WILDCARD);}		)*		(t = <WORD>		{s = s.concat(t.toString());}		)?)		| 		(t = <WORD>		{s = s.concat(t.toString());}		(<STRING_WILDCARD>		{s = s.concat(JAVA_REGEX_PATTERN_STRING_WILDCARD);}		t = <WORD>		{s = s.concat(t.toString());}		)*		(<STRING_WILDCARD>		{s = s.concat(JAVA_REGEX_PATTERN_STRING_WILDCARD);}		)?)	)		{return s;}}