options {	DEBUG_PARSER=true;	LOOKAHEAD=5;	STATIC=false;}PARSER_BEGIN(QueryLanguageParser)package modification.queryLanguageParser;import java.io.Reader;import java.io.StringReader;import java.util.List;import java.util.LinkedList;import java.util.regex.Pattern;import de.ovgu.cide.fstgen.ast.FSTNode;import de.ovgu.cide.fstgen.ast.FSTNonTerminal;public class QueryLanguageParser{	/**    *     */	private FSTNode root = null;		/**	*	*/	private static final String JAVA_REGEX_PATTERN_STRING_WILDCARD = "(.)*";	/**    *     */    public List<FSTNode> parse() throws ParseException {		return expression();    }	/**    *     */    public QueryLanguageParser(String query, FSTNode root) {		this((Reader) (new StringReader(query)));		this.root=root;    }        /**    *     */    private List<FSTNode> minus(List<FSTNode> a, List<FSTNode> b) {	List<FSTNode> result = new LinkedList<FSTNode>(a);		result.removeAll(b);                        return result;           }    /**    *     */    private List<FSTNode> and(List<FSTNode> a, List<FSTNode> b) {		List<FSTNode> result = new LinkedList<FSTNode>(a);		result.retainAll(b);         return result;    }    /**    *     */    private List<FSTNode> or(List<FSTNode> a, List<FSTNode> b) {	List<FSTNode> result = new LinkedList<FSTNode>(a);		result.removeAll(b);		result.addAll(b);        return result;    }}PARSER_END(QueryLanguageParser)SKIP:{	" "	| "\t"	| "\n"	| "\r"}	TOKEN:{	<UNION:"||">	| <INTERSECTION:"&&">	| <MINUS:"-">	| <ADDRESS_DIVIDER:".">	| <TYPE_DIVIDER:":">	| <ADDRESS_WILDCARD:"..">	| <STRING_WILDCARD:"*">	| <LEFT_BRACE:"(">	| <RIGHT_BRACE:")">}TOKEN:{	<NUMBER:["0"-"9"]>	| <SMALL_CHARACTER:["a"-"z"]>	| <GREAT_CHARACTER:["A"-"Z"]>}  /*** independent expression*/
List<FSTNode> expression():{	List<FSTNode> nodeListOp1 = new LinkedList<FSTNode>();	List<FSTNode> nodeListOp2 = new LinkedList<FSTNode>();	List<FSTNode> nodeListRes = new LinkedList<FSTNode>();}{	nodeListOp1 = queryTerm() {		nodeListRes = nodeListOp1;	} (		//union operator		(<UNION> nodeListOp2 = queryTerm() {			nodeListRes = nodeListOp1 = or(nodeListOp1, nodeListOp2);					}		| <INTERSECTION> nodeListOp2 = queryTerm()  {			nodeListRes = nodeListOp1 = and(nodeListOp1, nodeListOp2);		}		| <MINUS> nodeListOp2 = queryTerm() {			nodeListRes = nodeListOp1 = minus(nodeListOp1, nodeListOp2);		}		)	)* 		<EOF> 		{		return nodeListRes;	}}/*** query term without operators outside braces*/List<FSTNode> queryTerm():{	List<FSTNode> nodeList;	TreeAddress treeAddress;}{	((<LEFT_BRACE> nodeList = expression() <RIGHT_BRACE>) {		return nodeList;	}	| treeAddress = treeAddress()) {		return treeAddress.resolve(root);	}}/*** single tree address without operators*/TreeAddress treeAddress():{	List<TreeAddressToken> tokenList = new LinkedList<TreeAddressToken>();	List<TreeAddressToken> tempTokenList;}{		(			(			tempTokenList = literalAddress() 			{tokenList.addAll(tempTokenList);}			(				<ADDRESS_WILDCARD> 				{tokenList.add(new WildcardToken());}								tempTokenList = literalAddress() 				{tokenList.addAll(tempTokenList);}			)*		)							| 					(			<ADDRESS_WILDCARD>			{tokenList.add(new WildcardToken());}										tempTokenList = literalAddress()			{tokenList.addAll(tempTokenList);}		)+	)	{return new TreeAddress(tokenList);}}/*** */List<TreeAddressToken> literalAddress():{	List<TreeAddressToken> tokenList = new LinkedList<TreeAddressToken>();	TreeAddressToken token;}{	token = nameTypePatternToken()	{tokenList.add(token);}		(		<ADDRESS_DIVIDER>				token = nameTypePatternToken() 		{tokenList.add(token);}	)*		{return tokenList;}}/*** tokens split by <ADDRESS_DIVIDER>*/TreeAddressToken nameTypePatternToken():{	String name;	String type;}{	name = name()	<TYPE_DIVIDER>	type = type() {		return new NameTypePatternToken(name,type);	}}/*** */String name():{	String name;}{	name = stringWithWildcards() {		return name;	}}/*** */String type():{	String type;}{	type = stringWithWildcards() {		return type;	}	}/*** */String stringWithWildcards():{	String result = "";	Token t;	String s;}{	(	(<STRING_WILDCARD>		{result = result.concat(JAVA_REGEX_PATTERN_STRING_WILDCARD);}		(s = word()	{result = result.concat(s.toString());}		<STRING_WILDCARD>		{result = result.concat(JAVA_REGEX_PATTERN_STRING_WILDCARD);}		)*		(s = word()	{result = result.concat(s.toString());}		)?)		| 		(s = word()	{result = result.concat(s.toString());}		(<STRING_WILDCARD>		{result = result.concat(JAVA_REGEX_PATTERN_STRING_WILDCARD);}		s = word()	{result = result.concat(s.toString());}		)*		(<STRING_WILDCARD>		{result = result.concat(JAVA_REGEX_PATTERN_STRING_WILDCARD);}		)?)	)		{return result;}}String word():{	String m;	String s = "";	Token t;}{	(t = <SMALL_CHARACTER>	{s = s.concat(t.toString());}				|t = <GREAT_CHARACTER>		{s = s.concat(t.toString());}				|t = <NUMBER>		{s = s.concat(t.toString());}				|m = specialCharacter()		{s = s.concat(m);}			)+	{return s;}}String specialCharacter():{	String s = "";	Token t;}{		("%"			(t = "||"		{s = s.concat(t.toString());}				|t = "&&"		{s = s.concat(t.toString());}				|t = "-"		{s = s.concat(t.toString());}				|t = "."		{s = s.concat("\\.");}				|t = ":"		{s = s.concat(t.toString());}				|t = "*"		{s = s.concat(t.toString());}				|t = "("		{s = s.concat(t.toString());}				|t = ")"		{s = s.concat(t.toString());}				)	)		{return s;}}