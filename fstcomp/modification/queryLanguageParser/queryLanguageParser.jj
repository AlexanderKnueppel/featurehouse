options {	DEBUG_PARSER=true;	//LOOKAHEAD=5;	STATIC=false;	FORCE_LA_CHECK=true;}PARSER_BEGIN(QueryLanguageParser)package modification.queryLanguageParser;import java.io.Reader;import java.io.StringReader;import java.util.List;import java.util.LinkedList;import modification.queryLanguageParser.addressManagement.NameTypePatternToken;import modification.queryLanguageParser.addressManagement.TreeAddress;import modification.queryLanguageParser.addressManagement.TreeAddressToken;import modification.queryLanguageParser.addressManagement.WildcardToken;import de.ovgu.cide.fstgen.ast.FSTNode;public class QueryLanguageParser{	/**    *     */	private FSTNode root = null;		/**	*	*/	private static final String JAVA_REGEX_PATTERN_STRING_WILDCARD = "(.)*";	/**    *     */    public List<FSTNode> parse() throws ParseException {		return expression();    }	/**    *     */    public QueryLanguageParser(String query, FSTNode root) {		this((Reader) (new StringReader(query)));		this.root=root;    }        /**    *     */    private List<FSTNode> minus(List<FSTNode> a, List<FSTNode> b) {	List<FSTNode> result = new LinkedList<FSTNode>(a);		result.removeAll(b);                        return result;           }    /**    *     */    private List<FSTNode> and(List<FSTNode> a, List<FSTNode> b) {		List<FSTNode> result = new LinkedList<FSTNode>(a);		result.retainAll(b);         return result;    }    /**    *     */    private List<FSTNode> or(List<FSTNode> a, List<FSTNode> b) {	List<FSTNode> result = new LinkedList<FSTNode>(a);		result.removeAll(b);		result.addAll(b);        return result;    }}PARSER_END(QueryLanguageParser)SKIP:{	" "	| "\t"	| "\n"	| "\r"}	TOKEN:{	<UNION:"||">	| <INTERSECTION:"&&">	| <MINUS:"-">	| <ADDRESS_DIVIDER:".">	| <TYPE_DIVIDER:":">	| <ADDRESS_WILDCARD:"..">	| <STRING_WILDCARD:"*">	| <LEFT_BRACE:"(">	| <RIGHT_BRACE:")">	| <LITERAL_FLAG:"%">}TOKEN:{	<NUMBER:["0"-"9"]>	| <SMALL_CHARACTER:["a"-"z"]>	| <GREAT_CHARACTER:["A"-"Z"]>	| <ANY_CHAR:~[]>}  /*** independent expression*/
List<FSTNode> expression():{	List<FSTNode> nodeListOp1 = new LinkedList<FSTNode>();	List<FSTNode> nodeListOp2 = new LinkedList<FSTNode>();	List<FSTNode> nodeListRes = new LinkedList<FSTNode>();}{	nodeListOp1 = queryTerm()	{nodeListRes = nodeListOp1;}	(				<UNION> nodeListOp2 = queryTerm()		{nodeListRes = nodeListOp1 = or(nodeListOp1, nodeListOp2);}		|		<INTERSECTION> nodeListOp2 = queryTerm()		{nodeListRes = nodeListOp1 = and(nodeListOp1, nodeListOp2);}		|		<MINUS> nodeListOp2 = queryTerm()		{nodeListRes = nodeListOp1 = minus(nodeListOp1, nodeListOp2);}			)* 		<EOF> 		{return nodeListRes;}}/*** query term without operators outside braces*/List<FSTNode> queryTerm():{	List<FSTNode> nodeList;	TreeAddress treeAddress;}{	(		(			<LEFT_BRACE> 			nodeList = expression() 			<RIGHT_BRACE>		)		{return nodeList;}		|		treeAddress = treeAddress()	)	{return treeAddress.resolve(root);}}/*** single tree address without operators. * Differentiation with "|" to avoid the empty string.* splits off <ADDRESS_WILDCARD>s to treat seperately.*/TreeAddress treeAddress():{	List<TreeAddressToken> tokenList = new LinkedList<TreeAddressToken>();	List<TreeAddressToken> tempTokenList;}{		(			(			tempTokenList = literalAddress()			{tokenList.addAll(tempTokenList);}			(				<ADDRESS_WILDCARD> 				{tokenList.add(new WildcardToken());}								tempTokenList = literalAddress() 				{tokenList.addAll(tempTokenList);}			)*		)							| 					(			<ADDRESS_WILDCARD>			{tokenList.add(new WildcardToken());}						tempTokenList = literalAddress()			{tokenList.addAll(tempTokenList);}		)+	)	{return new TreeAddress(tokenList);}}/*** literalAddress consisting of nameTypePatternTokens and <ADDRESS_DIVIDER>s*/List<TreeAddressToken> literalAddress():{	List<TreeAddressToken> tokenList = new LinkedList<TreeAddressToken>();	TreeAddressToken token;}{	token = nameTypePatternToken()	{tokenList.add(token);}		(		<ADDRESS_DIVIDER>				token = nameTypePatternToken() 		{tokenList.add(token);}	)*		{return tokenList;}}/*** tokens split by <ADDRESS_DIVIDER> in literal addresses*/TreeAddressToken nameTypePatternToken():{	String name;	String type;}{	name = name()	<TYPE_DIVIDER>	type = type()	{return new NameTypePatternToken(name,type);}}/*** regex pattern for name part of nameTypePatternTokens*/String name():{	String name;}{	name = stringWithWildcards()	{return name;}}/*** regex pattern for type part of nameTypePatternTokens*/String type():{	String type;}{	type = stringWithWildcards() 	{return type;}	}/*** contains <STRING_WILDCARD>s and words mixed up in different ways*/String stringWithWildcards():{	String result = "";	Token t;	String s;}{		(				(			<STRING_WILDCARD>			{result = result.concat(JAVA_REGEX_PATTERN_STRING_WILDCARD);}			s = wildcardExtension()			{result = result.concat(s.toString());}							)			|				(			s = word()			{result = result.concat(s.toString());}			s = wordExtension()			{result = result.concat(s.toString());}							)	)		{return result;}}/*** possible extends for word*/String wordExtension():{	String result = "";	Token t;	String s;}{	(		(			<STRING_WILDCARD>			{result = result.concat(JAVA_REGEX_PATTERN_STRING_WILDCARD);}			(				s = word()				{result = result.concat(s.toString());}				s = wordExtension()				{result = result.concat(s.toString());}			)?		)?	)	{return result;}	}/*** possible extends for <STRING_WILDCARD>*/String wildcardExtension():{	String result = "";	Token t;	String s;}{	(		(			s = word()			{result = result.concat(s.toString());}			(				<STRING_WILDCARD>				{result = result.concat(JAVA_REGEX_PATTERN_STRING_WILDCARD);}				s = wildcardExtension()				{result = result.concat(s.toString());}			)?		)?	)	{return result;}}/*** word is consisting of <SMALL_CHARACTER>s, <GREAT_CHARACTER>s, * <NUMBER>s and specialCharacters (treated seperately)*/String word():{	String m;	String s = "";	Token t;}{	(		t = <SMALL_CHARACTER>		{s = s.concat("\\Q" + t.toString() + "\\E");}		|		t = <GREAT_CHARACTER>		{s = s.concat("\\Q" + t.toString() + "\\E");}		|		t = <NUMBER>		{s = s.concat("\\Q" + t.toString() + "\\E");}		|		m = specialCharacter()		{s = s.concat(m);}	)+	{return s;}}String specialCharacter():{	String s = "";	Token t;}{		(		<LITERAL_FLAG>		(			t = <ANY_CHAR>			{s = s.concat("\\Q" + t.toString() + "\\E");}						|			t = <UNION>			{s = s.concat("\\Q" + t.toString() + "\\E");}						|			t = <INTERSECTION>			{s = s.concat("\\Q" + t.toString() + "\\E");}						|			t = <MINUS>			{s = s.concat("\\Q" + t.toString() + "\\E");}						|			t = <ADDRESS_DIVIDER>			{s = s.concat("\\Q" + t.toString() + "\\E");}						|			t = <TYPE_DIVIDER>			{s = s.concat("\\Q" + t.toString() + "\\E");}						|			t = <STRING_WILDCARD>			{s = s.concat("\\Q" + t.toString() + "\\E");}						|			t = <LEFT_BRACE>			{s = s.concat("\\Q" + t.toString() + "\\E");}						|			t = <RIGHT_BRACE>			{s = s.concat("\\Q" + t.toString() + "\\E");}				)	)		{return s;}}