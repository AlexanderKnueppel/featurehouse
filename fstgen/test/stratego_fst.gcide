options {
	STATIC = false;
	FORCE_LA_CHECK = false;
}

PARSER_BEGIN(StrategoParser)
package tmp.generated_stratego;
import cide.gast.*;
import cide.gparser.*;
import de.ovgu.cide.fstgen.ast.*;

public class StrategoParser extends AbstractFSTParser 
{
	public StrategoParser(){}
}

PARSER_END(StrategoParser)

/*****************************************************************************
 * WHITE SPACE                                                               *
 *****************************************************************************/
SPECIAL_TOKEN : 
	{ " " | 
      "\t" | 
      "\n" | 
      "\r" | 
      "\f" 
    }
/*****************************************************************************
 * COMMENTS                                                                  *
 *****************************************************************************/
MORE :
	{ "//" : IN_SINGLE_LINE_COMMENT |
	  "%%" : IN_SINGLE_LINE_COMMENT_SDF |
	  <"/**" ~["/"]> { input_stream.backup(1); } : IN_FORMAL_COMMENT |
	  "/*" : IN_MULTI_LINE_COMMENT 
	}
	<IN_SINGLE_LINE_COMMENT>
		SPECIAL_TOKEN :
			{ <SINGLE_LINE_COMMENT: "\n" | "\r" | "\r\n" > : DEFAULT }
	<IN_SINGLE_LINE_COMMENT_SDF>
		SPECIAL_TOKEN :
			{ <SINGLE_LINE_COMMENT_SDF: "\n" | "\r" | "\r\n" > : DEFAULT }
	<IN_FORMAL_COMMENT>
		SPECIAL_TOKEN :
			{ <FORMAL_COMMENT: "*/" > : DEFAULT }
	<IN_MULTI_LINE_COMMENT>
		SPECIAL_TOKEN :
			{ <MULTI_LINE_COMMENT: "*/" > : DEFAULT }
	<IN_SINGLE_LINE_COMMENT,IN_SINGLE_LINE_COMMENT_SDF,
	 IN_FORMAL_COMMENT,IN_MULTI_LINE_COMMENT>
		MORE :
			{ < ~[] > }
/*****************************************************************************
 * RESERVED KEYWORDS AND LITERALS                                            *
 *****************************************************************************/
/*****************************************************************************
 * MODULE DECLARATION                                                        *
 *****************************************************************************/
 TOKEN :
 	{ < MODULE: "module" > |
 	  < SPECIFICATION: "specification" > |
 	  < IMPORTS: "imports" > | 
	  < EXPORTS: "exports" > |
	  < HIDDENS: "hiddens" >
 	}
/*****************************************************************************
 * GRAMMAR DECLARATION                                                       *
 *****************************************************************************/
 TOKEN :
 	{ < SORTS: "sorts" > |
 	  < STARTSYMBOL: "context-free start-symbols" >
 	}
/*****************************************************************************
 * PRODUCTION DECLARATION                                                    *
 *****************************************************************************/
 TOKEN :
 	{ < SYNTAX: "syntax" > |
	  < VARIABLES: "variables" > |
	  < LEXICALSYNTAX: "lexical syntax" > |
	  < CFREESYNTAX: "context-free syntax"> |
	  < LEXICALVARS: "lexical variables" > |
	  < CONS: "cons" > 
 	}
/*****************************************************************************
 * DISAMBIGUATION DECLARATION                                                *
 *****************************************************************************/
 TOKEN :
 	{ < LEFT: "left" > |
	  < ASSOC: "assoc" > |
	  < AVOID: "avoid" > |
	  < RIGHT: "right" > |
	  < PREFER: "prefer" > |
	  < BRACKET: "bracket" > |
	  < REJECT: "reject" > |
	  < NONASSOC: "non-assoc" > |
	  < RECOVER: "recover" > |
	  < DEPRECATED: "deprecated" > | 
	  < INDENTPADDING: "indentpadding" > |
	  < PRIORITIES: "priorities" > |
	  < CFREEPRIORITIES: "context-free priorities" > |
	  < LEXICALRESTRICTIONS: "lexical restrictions" > |
	  < CFREERESTRICTIONS: "context-free restrictions" > 
 	}
/*****************************************************************************
 * TRANSFORMATION DECLARATION                                                *
 *****************************************************************************/
TOKEN :
	{ < ALL: "all" > | 
	  < CONSTRUCTORS: "constructors" > | 
	  < FAIL: "fail" > |
	  < ID: "id" > | 
	  < IN: "in" > | 
	  < LET: "let" > |
	  < NOT: "not" > | 
	  < ONE: "one" > |
	  < DEPENDS: "depends" > |
	  < ON: "on" > |
	  < CALL: "call" > |
	  < PROCEED: "proceed" > |
	  < SIGNATURES: "signatures" > |
	  < WITH: "with" > |
	  < OVERLAYS: "overlays" > | 
	  < PRIM: "prim" > |
	  < RULES: "rules" > | 
	  < SCRIPT: "script" > | 
	  < SIGNATURE: "signature" > | 
	  < SOME: "some" > |
	  < STRATEGIES: "strategies" > | 
	  < STRATEGO: "stratego" > | 
	  < TEST: "test" > | 
	  < WHERE: "where" > | 
	  < IMPORTTERM: "import-term" > | 
	  < CASE: "case" > |
	  < ELSE: "else" > | 
	  < END: "end" > | 
	  < EXTERNAL: "external" > | 
	  < IF: "if" > |
	  < OTHERWISE: "otherwise" > | 
	  < REC: "rec" > | 
	  < SWITCH: "switch" > | 
	  < THEN: "then" > | 
	  < EXTEND: "extend" > | 
	  < OVERRIDE: "override" > |
	  < INTERNAL: "internal" > | 
	  < SEALED: "sealed" > | 
	  < EXTENSIBLE: "extensible" > |
	  < OVERRIDABLE: "overrideable" > 
	}
/*****************************************************************************
 * LITERALS                                                                  *
 *****************************************************************************/
TOKEN :
	{ < INTEGER_LITERAL:
		<DECIMAL_LITERAL> (["l","L"])? | 
	  	<HEX_LITERAL> (["l","L"])? | 
	  	<OCTAL_LITERAL> (["l","L"])? > |
	  < #DECIMAL_LITERAL: ["1"-"9"] (["0"-"9"])* > |
	  < #HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+ > |
	  < #OCTAL_LITERAL: "0" (["0"-"7"])* > |
	  < FLOATING_POINT_LITERAL:
    	(["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)? (["f","F","d","D"])? | 
    	"." (["0"-"9"])+ (<EXPONENT>)? (["f","F","d","D"])? | 
    	(["0"-"9"])+ <EXPONENT> (["f","F","d","D"])? | 
    	(["0"-"9"])+ (<EXPONENT>)? ["f","F","d","D"] > |
	  < #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ > |
	  < CHARACTER_LITERAL:
	  	"'" ( (~["'","\\","\n","\r"]) | 
			("\\"
				( ["n","t","b","r","f","u","\\","'","\""] | 
				  ["0"-"7"] ( ["0"-"7"] )? | 
				  ["0"-"3"] ["0"-"7"] ["0"-"7"] ) ) ) "'" > |
	  < STRING_LITERAL:
    	"\"" ( (~["\"","\\","\n","\r"]) | 
			("\\"
				( ["n","t","b","r","f","u","\\","'","\""] | 
				  ["0"-"7"] ( ["0"-"7"] )? | 
				  ["0"-"3"] ["0"-"7"] ["0"-"7"] ) ) )* "\"" >
	}
/*****************************************************************************
 * IDENTIFIER                                                                *
 *****************************************************************************/
/*TOKEN :
	{ < IDENTIFIER: (<LETTER>|<DIGIT>) (<LETTER>|<DIGIT>)* > |
	  < LETTER: (<LCCHAR>|<UCCHAR>) > |
	  < LCCHAR: [ "\u0061"-"\u007a" ] > |
	  < UCCHAR: [ "\u0041"-"\u005a" ] > |
	  < DIGIT: [ "\u0030"-"\u0039" ] > |
	  < LCCHAR: [ "a"-"z" ] > |
	  < UCCHAR: [ "A"-"Z" ] > |
	  < DIGIT: [ "0"-"9" ] >
	}*/
TOKEN :
	{ < IDENTIFIER: (<LETTER>|<LOWLINE>|<DIGIT>) 
	                (<LETTER>|<DIGIT>|<APOSTROPHE>|<MINUS>|<LOWLINE>)* > |
	  < LETTER: (<LCCHAR>|<UCCHAR>) > |
	  < LCCHAR: [ "a"-"z" ] > |
	  < UCCHAR: [ "A"-"Z" ] > |
	  < DIGIT: [ "0"-"9" ] >
	}
/*****************************************************************************
 * PARENTHESIS                                                               *
 *****************************************************************************/
TOKEN :
	{ < LPAREN: "(" > | 
	  < RPAREN: ")" > | 
	  < LBRACE: "{" > | 
	  < RBRACE: "}" > | 
	  < LBRACKET: "[" > |
	  < RBRACKET: "]" > |
	  < DLBRACKET: "[[" > | 
	  < DRBRACKET: "]]" > |
	  < LT: "<" > |
	  < GT: ">" > 
	}
/*****************************************************************************
 * OPERATORS                                                                 *
 *****************************************************************************/
TOKEN :
	{ < PLUS: "+" > |
	  < MINUS: "-" > |
	  < STAR: "*" > |
	  < SLASH: "/" >
	}
/*****************************************************************************
 * SEPARATORS                                                                *
 *****************************************************************************/
TOKEN :
	{ < COMMA: "," > |
	  < SEMICOLON: ";" > |
	  < DDOT: ":" > |
	  < DOT: "." > |
	  < QUESTIONMARK: "?" > |
	  < EXCLAMATIONMARK: "!" >
	}
/*****************************************************************************
 * SPECIAL SIGNS                                                             *
 *****************************************************************************/
TOKEN :
	{ < NUMBERSIGN: "#" > |
	  < AT: "@" > |
	  < DOLLAR: "$" > |
	  < VERTICALLINE: "|" > |
	  < TILDE: "~" > |
	  < AMPERSAND: "&" > |
	  < PERCENTAGE: "%" > |
	  < CIRCUMFLEXACCENT: "^" > |
	  < GRAVEACCENT: "`" > |
	  < APOSTROPHE: "'" > |
	  < ARROW: "->" > |
	  < ASSIGN: "=" > |
	  < NOTALLOWED: "-/-" > |
	  < LOWLINE: "_" > |
	  < QUOTATIONMARK: "\"" > |
	  < BACKSLASH: "\\" >
	}

/*****************************************************************************
 * THE STRATEGO LANGUAGE GRAMMAR STARTS HERE                                 *
 *****************************************************************************/
GRAMMARSTART
 
/*****************************************************************************
 * LITERALS                                                                  *
 *****************************************************************************/
NatInteger : 
	<INTEGER_LITERAL> ;

RealDigit: 
	<INTEGER_LITERAL> "." <INTEGER_LITERAL> ;

Int : 
	[<MINUS>] NatInteger ;

Real : 
	[<MINUS>] RealDigit ;

String : 
	<STRING_LITERAL> ;

Char :
	<CHARACTER_LITERAL> ;

@FSTTerminal(name="{<IDENTIFIER>}")
Id :
	<IDENTIFIER> ;

/*****************************************************************************
 * MAIN PRODUCTION                                                           *
 *****************************************************************************/
Module : 
	ModuleDeclaration
	[ImportDeclaration]
	[ExportDeclaration]
	[HiddenDeclaration]
	[TrafoDeclaration]
	<EOF> ;

ModuleDeclaration :
	"module" ModName [ModuleParameter] @+! ;

ModuleParameter :
	"[" (ModuleSort)+ "]" ;

ModuleSort :
	Id |
	"[[" Id "]]" ;

ModName :
	Id (LOOK_AHEAD(2) "/" Id)* ;

ImportModName : 
	ModName [ModuleParameter] ;

@FSTTerminal(name="{ModName}{ImportModule}")
ImportDeclaration :
	"imports" (ImportModName)+ ;

ExportDeclaration :
	"exports" (Grammer)+ ;

HiddenDeclaration :
	"hiddens" (Grammer)+ ;

Grammer :
	/* Every syntax definition introduces names for the syntactical sorts 
	   of a language. */
	"sorts" (Sort)* |
	/* Every syntax definition needs to define one or more start symbols. */
	"context-free start-symbols" (Sort)* |
	Productions |
	Disambiguations ;

/* The actual syntax is defined in lexical and context-free syntax.
   The lexical syntax defines the syntax of language constructs like literals, 
   comments, whitespace, and identifiers, or what is usally referred to as 
   terminals. 
   The context-free syntax defines the syntax of constructs like operators, 
   statements, or what is usually referred to as non-terminals */
Productions :
	ProdPart (Production)* ;

ProdPart :
	"syntax" <NONE> |
	"lexical syntax" <NONE> |
	"context-free syntax" <NONE> |
	"variables" <NONE> |
	"lexical variables" <NONE> ;

/* Constructs to define in a declarative way that certain kinds of derivations 
   are not allowed, also known as disambiguation filters */
Disambiguations :
	"context-free priorities" (Priority)* |
	"lexical restrictions" (Restriction)* |
	"context-free restrictions" (Restriction)* ;

/* Productions have the form A1 ... An -> A0, where A0 is non-terminal and 
   A1 ... An is a string of terminals and non-terminals. */
Production :
	(Symbol)* 
	"->" (LOOK_AHEAD(2) Symbol)+ [LOOK_AHEAD("\"{\" Attribute()") OptAttributes] ;

/* There are three kinds of symbols: sorts, character classes and literals. 
   Sorts are names for language specific constructs.
   A character class is set of characters. Character classes are specified 
   by single characters, character ranges, and can be combined using set 
   operators, such as complement, difference, union, intersection.
   A literal is a String. */
Symbol :
	LOOK_AHEAD(2) "(" Symbol ")" [SortOp] |
	Sort [AlternativeSymbol] |
	CharacterClass [AlternativeSymbol] |
	String [SortOp] [AlternativeSymbol] ;

AlternativeSymbol :
	"|" Symbol ;

Sort :
	"[[" Id "]]" |
	"<" Id [SortOp] ["-" Id] ">" |
	Id [SortOp] |	
	"{" Id String "}" [SortOp] |
	"(" (Sort)+ ")" [SortOp] ;

SortOp :
	"*" | 
	"+" | 
	"?" ;

CharacterClass :
	[<TILDE>] "[" (CharClass)* "]" [SortOp] ;

CharClass :
	LOOK_AHEAD(2) "\\" OptCharClass1 |
	[OptCharClass2] Id |
	Int ;

OptCharClass1 :
	LOOK_AHEAD(2) SpecialSign |
	Int ;

OptCharClass2 :
	"\\"<NONE> ;

SpecialSign :
	"("<NONE> | 
	")"<NONE> | 
	"{"<NONE> |
	"}"<NONE> |
	"["<NONE> |
	"]"<NONE> |
	","<NONE> |
	"<"<NONE> |
	">"<NONE> |
	":"<NONE> |
	"."<NONE> |
	"?"<NONE> |
	"!"<NONE> |
	"'"<NONE> |
	"%"<NONE> |
	/*"_"<NONE> |*/
	"$"<NONE> |
	"@"<NONE> |
	"~"<NONE> |
	"\""<NONE> |
	"/"<NONE> |
	"\\"<NONE> |
	"#"<NONE> |
	"|"<NONE> |
	"+"<NONE> |
	"-"<NONE> |
	"*"<NONE> |
	";"<NONE> |
	"`"<NONE> |
	"="<NONE> |
	"&"<NONE> |
	"^"<NONE> |
	"t"<NONE> |
	"n"<NONE> |
	"r"<NONE> ;

OptAttributes :
	"{" Attribute (LOOK_AHEAD(2) "," Attribute)* "}" ;

Attribute :
	"bracket"<NONE> |
	"prefer"<NONE> |
	"avoid"<NONE> |
	"left"<NONE> |
	"right"<NONE> |
	"non-assoc"<NONE> |
	"assoc"<NONE> |
	"reject"<NONE> |
	"recover"<NONE> |
	"indentpadding"<NONE> |
	Constructor ;

Constructor :
	"cons" "(" String ")" |
	"deprecated" "(" String ")" ;

Priority :
	LOOK_AHEAD(3) "{" [Attribute ":"] @! (Production)+ "}" ">" Production |
	Production ">" Prio ;

/*[LOOK_AHEAD(2) Production] (LOOK_AHEAD(2) ">" Production)*/

Prio :
	LOOK_AHEAD(3) "{" [Attribute ":"] @!(Production)+ "}" |
	Production (LOOK_AHEAD(2) ">" Production)* ;

Restriction : 
	(Symbol)+ "-/-" CharacterClass (LOOK_AHEAD(2) "." CharacterClass)* ;

/*****************************************************************************
 * TRANSFORMATIONS                                                           *
 *****************************************************************************/
TrafoDeclaration :
	"rules" (Definition)* ;
	
Definition :
	LOOK_AHEAD(2) RuleDef |
	StrategyDef ;

RuleDef :
	RuleName ":" Rule ;

RuleName :
	Id ;

Rule :
	Term "->" Term (RuleCond)* ;

RuleCond :
	"where" Strategy |
	"with" Strategy ;

StrategyDef :
	Id "=" Strategy ;

Strategy :
	LOOK_AHEAD(3) "<" Strategy ">" [LOOK_AHEAD(2) Term] [AlternativeStrategy] |
	"if" Strategy "then" Strategy ["else" Strategy] "end" [AlternativeStrategy] |
	"switch" Strategy (SwitchCase)* ["otherwise" ":" Strategy] 
	         "end" [AlternativeStrategy] |
	"let" (Definition)* "in" Strategy "end" [AlternativeStrategy] |
	"call" "(" Term "|" Strategy (LOOK_AHEAD(2) "," Strategy)* "|" 
	           Term (LOOK_AHEAD(2) "," Term)* ")" [AlternativeStrategy] |
	LOOK_AHEAD(3) "prim" "(" String "," [LOOK_AHEAD(2) OptStrategy3] 
	              Term (LOOK_AHEAD(2) "," Term)* ")" [AlternativeStrategy] |
	"proceed" [OptStrategy1] [AlternativeStrategy] |
	"fail"<NONE> [AlternativeStrategy] |
	"id"<NONE> [AlternativeStrategy] |
	"?" Term [AlternativeStrategy] |
	"!" Term [AlternativeStrategy] |
	"rec" Id "(" Strategy ")"  [AlternativeStrategy] |
	"import-term" "(" ModName ")"  [AlternativeStrategy] |
	"rules" "(" (DynRuleDef)* ")" [AlternativeStrategy] |
	LOOK_AHEAD(3) 
	"(" Strategy (LOOK_AHEAD(2) "," Strategy)* ")" [AlternativeStrategy] |
	LOOK_AHEAD(3) 
	"{" Id (LOOK_AHEAD(2) "," Id)* ":" Strategy "}" [AlternativeStrategy] |
	LOOK_AHEAD(3) 
	"[" Strategy (LOOK_AHEAD(2) "," Strategy)* ["|" Strategy] "]" [AlternativeStrategy]|
	"{" Strategy "}" [AlternativeStrategy] |
	"\\" Rule "\\" [AlternativeStrategy] |
	LOOK_AHEAD(3) "(" Rule ")" [AlternativeStrategy] |
	"{|" ScopeLabels ":" Strategy "|}" [AlternativeStrategy] |
	Strategies ;

Strategies :
	Strat "(" Strategy ")" [AlternativeStrategy] |
	LOOK_AHEAD(3) Term ":=" Term [AlternativeStrategy] |
	Id [OptStrategy1] [AlternativeStrategy] |
	String [OptStrategy1] [AlternativeStrategy] |
	LOOK_AHEAD(3) Int [AlternativeStrategy] |
	Real [AlternativeStrategy] ;

AlternativeStrategy :
	Operator Strategy ;

Operator :
	";" |
	"+" |
	"<+" |
	"+>" ;

Strat :
	"some"<NONE> |
	"one"<NONE> |
	"all"<NONE> |
	"not"<NONE> |
	"where"<NONE> |
	"with"<NONE> |
	"test"<NONE> |
	"prim"<NONE> ;

SwitchCase :
	"case" Strategy ":" Strategy ;

ScopeLabels :
	"~" Term |
	DynRuleScopeId (LOOK_AHEAD(2) "," DynRuleScopeId)* ;

DynRuleScopeId :
	LOOK_AHEAD(2) Id "." Term |
	Id ;

DynRuleDef :
	LOOK_AHEAD(3) Id "+" Term |
	LOOK_AHEAD(3) DynRuleId TermOperator Term |
	LOOK_AHEAD(3) DynRuleId RuleOperator Term |
	DynRuleId ":" Rule "depends" "on" Term ;

DynRuleId :
	RuleDec [OptRuleDec3] ;

RuleDec :
	Id [OptRuleDec1] ;

OptRuleDec1 :
	"(" TypedId (LOOK_AHEAD(2) "," TypedId)* [OptRuleDec2] ")" ;

OptRuleDec2 :
	"|" TypedId (LOOK_AHEAD(2) "," TypedId)* ;

OptRuleDec3 :
	RuleDecOperator Term ;

RuleDecOperator :
	"+" |
	"." ;

TermOperator :
	":-"<NONE> |
	":"<NONE> |
	":="<NONE> |
	":+="<NONE> ;

RuleOperator :
	":"<NONE> |
	":+"<NONE> ;

TypedId :
	Id ":" Type ;

Type :
	LOOK_AHEAD(3) FunType |
	ConstType ;

FunType :
	ArgType (LOOK_AHEAD(2) "*" ArgType)* "->" RetType ;

ArgType :
	"(" Type ")" |
	ConstType ;

ConstType :
	TrafoSort ;

RetType :
	Type ;

TrafoSort :
	Id [Sorts] ;

Sorts :
	"(" TrafoSort (LOOK_AHEAD(2) "," TrafoSort)* ")" |
	"[" TrafoSort (LOOK_AHEAD(2) "," TrafoSort)* [OptSorts] "]" ;

OptSorts :
	"|" TrafoSort ;

OptStrategy1 :
	"(" Strategy (LOOK_AHEAD(2) "," Strategy)* [OptStrategy2] ")" ;

OptStrategy2 :
	"|" Term (LOOK_AHEAD(2) "," Term)* ;

OptStrategy3 :
	Strategy (LOOK_AHEAD(2) "," Strategy)* "|" ;

Term :
	"_" [LOOK_AHEAD(2) Term] |
	"<" Strategy ">" [LOOK_AHEAD(2) Term] |
	PreTerm [OptTerm1] |
	Id [LOOK_AHEAD(2) SortOp] [OptTerm2] ;

PreTerm :
	"(" Term (LOOK_AHEAD(2) "," Term)* ")" [AlternativePreTerm] |
	"[" Term (LOOK_AHEAD(2) "," Term)* [OptTerm4] "]" [AlternativePreTerm] |
	LOOK_AHEAD(3)
	Int [AlternativePreTerm] |
	Real [AlternativePreTerm] |
	String [OptTerm3] [AlternativePreTerm] ;
	
AlternativePreTerm :
	"#" "(" Term ")" ;

OptTerm1 :
	"{" Term (LOOK_AHEAD(2) "," Term)* "}" | 
	"{^" PreTerm "}" ;

OptTerm2 :
	"@" Term |
	"(" Term (LOOK_AHEAD(2) "," Term)* ")" ;

OptTerm3 :
	"(" Term (LOOK_AHEAD(2) "," Term)* ")" ;

OptTerm4 :
	"|" Term ;