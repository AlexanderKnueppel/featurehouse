options {
	STATIC = false;
	FORCE_LA_CHECK = false;
	DEBUG_PARSER = true;
}

PARSER_BEGIN(StrategoParser)
package tmp.generated_stratego;
import cide.gast.*;
import cide.gparser.*;
import de.ovgu.cide.fstgen.ast.*;

public class StrategoParser extends AbstractFSTParser
{
	public StrategoParser(){}
}

PARSER_END(StrategoParser)

/*****************************************************************************
 * WHITE SPACE                                                               *
 *****************************************************************************/
SPECIAL_TOKEN :
	{ " " |
      "\t" |
      "\n" |
      "\r" |
      "\f"
    }
/*****************************************************************************
 * COMMENTS                                                                  *
 *****************************************************************************/
MORE :
	{ "//" : IN_SINGLE_LINE_COMMENT |
	  <"/**" ~["/"]> { input_stream.backup(1); } : IN_FORMAL_COMMENT |
	  "/*" : IN_MULTI_LINE_COMMENT
	}
	<IN_SINGLE_LINE_COMMENT>
		SPECIAL_TOKEN :
			{ <SINGLE_LINE_COMMENT: "\n" | "\r" | "\r\n" > : DEFAULT }
	<IN_FORMAL_COMMENT>
		SPECIAL_TOKEN :
			{ <FORMAL_COMMENT: "*/" > : DEFAULT }
	<IN_MULTI_LINE_COMMENT>
		SPECIAL_TOKEN :
			{ <MULTI_LINE_COMMENT: "*/" > : DEFAULT }
	<IN_SINGLE_LINE_COMMENT,IN_FORMAL_COMMENT,IN_MULTI_LINE_COMMENT>
		MORE :
			{ < ~[] > }
/*****************************************************************************
 * RESERVED KEYWORDS AND LITERALS                                            *
 *****************************************************************************/
/*****************************************************************************
 * MODULE DECLARATION                                                        *
 *****************************************************************************/
TOKEN :
	{ < MODULE: "module" > |
	  < SPECIFICATION: "specification" > |
	  < IMPORTS: "imports" >
	}
/*****************************************************************************
 * GRAMMAR DECLARATION                                                       *
 *****************************************************************************/
TOKEN :
	{ < SORTS: "sorts" > }
/*****************************************************************************
 * PRODUCTION DECLARATION                                                    *
 *****************************************************************************/
TOKEN :
	{ < CONS: "cons" > }
/*****************************************************************************
 * DISAMBIGUATION DECLARATION                                                *
 *****************************************************************************/
TOKEN :
	{ < LEFT: "left" > |
	  < ASSOC: "assoc" > |
	  < AVOID: "avoid" > |
	  < RIGHT: "right" > |
	  < PREFER: "prefer" > |
	  < BRACKET: "bracket" > |
	  < REJECT: "reject" > |
	  < NONASSOC: "non-assoc" > |
	  < RECOVER: "recover" > |
	  < DEPRECATED: "deprecated" > |
	  < INDENTPADDING: "indentpadding" >
	}
/*****************************************************************************
 * TRANSFORMATION DECLARATION                                                *
 *****************************************************************************/
TOKEN :
	{ < ALL: "all" > |
	  < CONSTRUCTORS: "constructors" > |
	  < FAIL: "fail" > |
	  < ID: "id" > |
	  < IN: "in" > |
	  < LET: "let" > |
	  < NOT: "not" > |
	  < ONE: "one" > |
	  < DEPENDS: "depends" > |
	  < ON: "on" > |
	  < CALL: "call" > |
	  < PROCEED: "proceed" > |
	  < SIGNATURES: "signatures" > |
	  < WITH: "with" > |
	  < OVERLAYS: "overlays" > |
	  < PRIM: "prim" > |
	  < RULES: "rules" > |
	  < SCRIPT: "script" > |
	  < SIGNATURE: "signature" > |
	  < SOME: "some" > |
	  < STRATEGIES: "strategies" > |
	  < STRATEGO: "stratego" > |
	  < TEST: "test" > |
	  < WHERE: "where" > |
	  < IMPORTTERM: "import-term" > |
	  < CASE: "case" > |
	  < ELSE: "else" > |
	  < END: "end" > |
	  < EXTERNAL: "external" > |
	  < IF: "if" > |
	  < OTHERWISE: "otherwise" > |
	  < REC: "rec" > |
	  < SWITCH: "switch" > |
	  < THEN: "then" > |
	  < EXTEND: "extend" > |
	  < OVERRIDE: "override" > |
	  < INTERNAL: "internal" > |
	  < SEALED: "sealed" > |
	  < EXTENSIBLE: "extensible" > |
	  < OVERRIDABLE: "overrideable" >
	}
/*****************************************************************************
 * LITERALS                                                                  *
 *****************************************************************************/
TOKEN :
	{ < INTEGER_LITERAL:
		<DECIMAL_LITERAL> (["l","L"])? |
	  	<HEX_LITERAL> (["l","L"])? |
	  	<OCTAL_LITERAL> (["l","L"])? > |
	  < #DECIMAL_LITERAL: ["1"-"9"] (["0"-"9"])* > |
	  < #HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+ > |
	  < #OCTAL_LITERAL: "0" (["0"-"7"])* > |
	  < FLOATING_POINT_LITERAL:
    	(["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)? (["f","F","d","D"])? |
    	"." (["0"-"9"])+ (<EXPONENT>)? (["f","F","d","D"])? |
    	(["0"-"9"])+ <EXPONENT> (["f","F","d","D"])? |
    	(["0"-"9"])+ (<EXPONENT>)? ["f","F","d","D"] > |
	  < #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ > |
	  < CHARACTER_LITERAL:
	  	"'" ( (~["'","\\","\n","\r"]) |
			("\\"
				( ["n","t","b","r","f","u","\\","'","\""] |
				  ["0"-"7"] ( ["0"-"7"] )? |
				  ["0"-"3"] ["0"-"7"] ["0"-"7"] ) ) ) "'" > |
	  < STRING_LITERAL:
    	"\"" ( (~["\"","\\"]) |
			 ("\\"
				( ["n","t","b","r","f","u","\\","'","\""] |
				  ["0"-"7"] ( ["0"-"7"] )? |
				  ["0"-"3"] ["0"-"7"] ["0"-"7"] ) ) )* "\"" >
	}
/*****************************************************************************
 * IDENTIFIER                                                                *
 *****************************************************************************/
TOKEN :
	{ < IDENTIFIER: (<LETTER>|<DIGIT>|<APOSTROPHE>)
	                (<LETTER>|<DIGIT>|<APOSTROPHE>|<MINUS>)* (<STAR>)? > |
	  < LETTER: (<LCCHAR>|<UCCHAR>) > |
	  < LCCHAR: [ "a"-"z" ] > |
	  < UCCHAR: [ "A"-"Z" ] > |
	  < DIGIT: [ "0"-"9" ] >
	}
/*****************************************************************************
 * PARENTHESIS                                                               *
 *****************************************************************************/
TOKEN :
	{ < LPAREN: "(" > |
	  < RPAREN: ")" > |
	  < LBRACE: "{" > |
	  < RBRACE: "}" > |
	  < LBRACKET: "[" > |
	  < RBRACKET: "]" > |
	  < LT: "<" > |
	  < GT: ">" >
	}
/*****************************************************************************
 * OPERATORS                                                                 *
 *****************************************************************************/
TOKEN :
	{ < PLUS: "+" > |
	  < MINUS: "-" > |
	  < STAR: "*" > |
	  < SLASH: "/" >
	}
/*****************************************************************************
 * SEPARATORS                                                                *
 *****************************************************************************/
TOKEN :
	{ < COMMA: "," > |
	  < SEMICOLON: ";" > |
	  < DDOT: ":" > |
	  < DOT: "." > |
	  < QUESTIONMARK: "?" > |
	  < EXCLAMATIONMARK: "!" >
	}
/*****************************************************************************
 * SPECIAL SIGNS                                                             *
 *****************************************************************************/
TOKEN :
	{ < NUMBERSIGN: "#" > |
	  < AT: "@" > |
	  < DOLLAR: "$" > |
	  < VERTICALLINE: "|" > |
	  < TILDE: "~" > |
	  < AMPERSAND: "&" > |
	  < PERCENTAGE: "%" > |
	  < CIRCUMFLEXACCENT: "^" > |
	  < GRAVEACCENT: "`" > |
	  < APOSTROPHE: "'" > |
	  < ARROW: "->" > |
	  < ASSIGN: "=" > |
	  < LOWLINE: "_" > |
	  < QUOTATIONMARK: "\"" > |
	  < BACKSLASH: "\\" >
	}

/*****************************************************************************
 * THE STRATEGO LANGUAGE GRAMMAR STARTS HERE                                 *
 *****************************************************************************/
GRAMMARSTART

/*****************************************************************************
 * LITERALS                                                                  *
 *****************************************************************************/
NatInteger :
	<INTEGER_LITERAL> ;

RealDigit:
	<INTEGER_LITERAL> "." <INTEGER_LITERAL> ;

Int :
	[<MINUS>] NatInteger ;

Real :
	[<MINUS>] RealDigit ;

String :
	<STRING_LITERAL> ;

Char :
	<CHARACTER_LITERAL> ;

Id :
	<IDENTIFIER> ;

/*****************************************************************************
 * MAIN PRODUCTION                                                           *
 *****************************************************************************/
Module :
	ModuleDeclaration
	(Declaration)*
	<EOF> ;

ModName :
	Id (LOOK_AHEAD(2) "/" Id)* ;

ModuleDeclaration :
	"module" ModName
	| "specification"<NONE>
	;

Declaration :
	"imports" (ModName)+
	| "rules" (Definition)+
	| "strategies" (Definition)+
	| "signature" (SigDeclaration)+
	| "signatures" (SigDeclaration)+
	| "overlays" (Overlay)+
	;

Overlay :
	Id [OptOverlay] "=" Term ;

OptOverlay :
	"(" [IdList] ")" ;

SigDeclaration :
	"sorts" (TrafoSort)*
	| "constructors" (OpDeclaration)*
	;

TrafoSort :
	BracketSort
	| Id [LOOK_AHEAD("OptSort1()") OptSort1] // TODO
	;

OptSort1 :
	"(" [TrafoSortList] ")" ;

BracketSort :
	"[" [TrafoSortList] [OptSort2] "]"
	| OptSort1
	;

OptSort2 :
	"|" TrafoSort ;

OpDeclaration :
	[OptOpDecl1] [OptOpDecl2] ":" Type ;

OptOpDecl1 :
	"external"<NONE> ;

OptOpDecl2 :
	Id
	| String
	;

Definition :
	(Anno)* Def ;

Anno :
	"extend"<NONE>
	| "override"<NONE>
	| "internal"<NONE>
	;

Def :
	LOOK_AHEAD("Id() [OptDef1()] \":\"") RuleDef
	| StrategyDef
	;

RuleDef :
	Id [OptDef1] ":" Rule ;

OptDef1 :
	"(" [TypedIdList] [OptDef2] ")" ; // TODO nur "(" ")" erlaubt?

OptDef2 :
	"|" [TypedIdList] ; // TODO nur "|" erlaubt?

Rule :
	Term "->" Term (RuleCond)* ;  // TODO + -> *

RuleCond :
	"where" Strategy
	| "with" Strategy
	;

StrategyDef :
	"external" [Id] "(" [TypedIdList] "|" [TypedIdList] ")" ["=" Strategy] // TODO
	| Id [OptDef1] "=" Strategy
	;

Strategy :
	"if" Strategy "then" Strategy ["else" Strategy] "end" [AlternativeStrategy]
	| "switch" Strategy (SwitchCase)* ["otherwise" ":" Strategy] "end" [AlternativeStrategy]
	| "let" (Definition)* "in" Strategy "end" [AlternativeStrategy]
	| "call" "(" Term "|" [StrategyList] "|" [TermList] ")" [AlternativeStrategy]
	| "proceed" [OptStrategy] [AlternativeStrategy]
	| "fail"<NONE> [AlternativeStrategy]
	| "id"<NONE> [AlternativeStrategy]
	| "?" Term [AlternativeStrategy]
	| "!" Term [AlternativeStrategy]
	| "rec" Id "(" Strategy ")"	[AlternativeStrategy]
	| "import-term" "(" ModName ")" [AlternativeStrategy]
	| "\\" Rule "\\" [AlternativeStrategy]
	| "{|" ScopeLabels ":" Strategy "|}" [AlternativeStrategy]
	| "rules" "(" (DynRuleDef)* ")" [AlternativeStrategy]
	| Strat "(" Strategy ")" [AlternativeStrategy]
	| "prim" "(" String [OptPrimStrategy] ")" [AlternativeStrategy]
	| LOOK_AHEAD("Term() \":=\"") Term ":=" Term [AlternativeStrategy]
	| "(" OptRuleOrStrategy ")" [AlternativeStrategy]
	| StrategyCurly [AlternativeStrategy]
	| StrategyAngle Term [AlternativeStrategy]
	| "[" [StrategyList] ["|" Strategy] "]" [AlternativeStrategy]
	| Id [OptStrategy] [AlternativeStrategy]
	| String [OptStrategy] [AlternativeStrategy]
	| LOOK_AHEAD("Real()") Real [AlternativeStrategy]
	| Int [AlternativeStrategy]
	;

	/*
	"/" RuleNames "\\*" Strategy
	Strategy StrategyCurly
	Strategy "/" RuleNames "\\" Strategy
	Strategy "\\" RuleNames "/" Strategy
	Strategy "/" RuleNames "\\" RuleNames "/" Strategy
	Strategy "<" Strategy "+" Strategy
	 */

Strat :
	"some"<NONE>
	| "one"<NONE>
	| "all"<NONE>
	| "not"<NONE>
	| "where"<NONE>
	| "with"<NONE>
	| "test"<NONE>
	;

/* Hilfskonstrukt zum Aufloesen von Linksrekursion */
AlternativeStrategy :
	AlternativeOperator Strategy
	| "=>" Term
	;

AlternativeOperator :
	";"<NONE>
	| "+"<NONE>
	| "<+"<NONE>
	| "+>"<NONE>
	;

OptPrimStrategy :
	"," [LOOK_AHEAD("StrategyList() \"|\"") StrategyList "|"] [TermList] ;

OptRuleOrStrategy :
	LOOK_AHEAD("Rule()") Rule
	| [StrategyList]
	;

StrategyCurly :
	"{" [LOOK_AHEAD("OptStrategyCurly()") OptStrategyCurly] Strategy "}" ;

OptStrategyCurly :
	[IdList] ":" ;

StrategyAngle :
	"<" Strategy ">" ;

OptStrategy :
	"(" [StrategyList] [OptTerm] ")" ;

OptTerm :
	"|" [TermList] ;

SwitchCase :
	"case" Strategy ":" Strategy ;

ScopeLabels :
	"~" Term
	| [DynRuleScopedIdList]
	;

DynRuleScopeId :
	LOOK_AHEAD(2) Id "." Term
	| Id
	;

DynRuleDef :
	LOOK_AHEAD("DynRuleId() \":\" Rule() \"depends\"") DynRuleId ":" Rule "depends" "on" Term
	| LOOK_AHEAD("DynRuleId() \":\"") DynRuleId ":" RuleOrTerm
	| LOOK_AHEAD("DynRuleId() \":+\"") DynRuleId ":+" Rule
	| LOOK_AHEAD("DynRuleId() TermOperator()") DynRuleId TermOperator Term
	| Id "+" Term
	;

RuleOrTerm :
	LOOK_AHEAD("Term() \"->\"") Rule
	| Term
	;

DynRuleId :
	RuleDec [OptRuleDec3] ;

RuleDec :
	Id [OptRuleDec1] ;

OptRuleDec1 :
	"(" [TypedIdList] [OptRuleDec2] ")" ; // TODO ist "(" ")" ein gueltiger Ausdruck?

OptRuleDec2 :
	"|" [TypedIdList] ; // TODO ist ein einzelnen "|" gueltig?

OptRuleDec3 :
	RuleDecOperator Term ;

RuleDecOperator :
	"+"
	| "."
	;

TermOperator :
	":-"<NONE>
	| ":="<NONE>
	| ":+="<NONE>
	;

RuleNames :
	"~" Term
	| [IdList]
	;

TypedId :
	Id [":" Type] ;

Type :
	LOOK_AHEAD("FunType()") FunType
	| TrafoSort
	;

FunType :
	ArgType (LOOK_AHEAD(2) "*" ArgType)* "->" Type ;

ArgType :
	LOOK_AHEAD("TrafoSort()") TrafoSort
	| "(" Type ")"
	;

/* Hilfskonstrukt zum Aufloesen von Linksrekursion */
AlternativePreTerm :
	"#" "(" Term ")" ;

Term :
	StrategyAngle [Term] // TODO in welchen Faellen kommt ein Term? Kann ueberhaupt entschieden werden, dass danach ein Term kommt?
	| "_" [Term]
	| LOOK_AHEAD("Id() \"(\"") PreTerm [OptPreTerm]
	| Id ["@" Term]  // TODO unreachable code
	;

PreTerm :
	Id "(" [TermList] ")" [AlternativePreTerm] // TODO ist "(" ")" ein gueltiger Ausdruck?
	| LOOK_AHEAD("Real()") Real [AlternativePreTerm]
	| Int [AlternativePreTerm]
	| String [OptStringTerm] [AlternativePreTerm]
	| "(" [TermList] ")" [AlternativePreTerm] // TODO ist "(" ")" ein gueltiger Ausdruck?
	| "[" [TermList] ["|" Term] "]" [AlternativePreTerm] // TODO ist "[" "]" ein gueltiger Ausdruck?
	;

OptPreTerm :
	"{" [TermList] "}" // TODO ist "{" "}" ein gueltiger Ausdruck?
	| "{^" PreTerm "}"
	;

OptStringTerm :
	"(" [TermList] ")" ; // TODO ist "(" ")" ein gueltiger Ausdruck?

/*****************************************************************************
 * DEFINITION OF LISTS                                                       *
 *****************************************************************************/
IdList :
	Id (LOOK_AHEAD(2) "," Id)* ;

TermList :
	Term (LOOK_AHEAD(2) "," Term)* ;

TypedIdList :
	TypedId (LOOK_AHEAD(2) "," TypedId)* ;

StrategyList :
	Strategy (LOOK_AHEAD(2) "," Strategy)* ;

DynRuleScopedIdList :
	DynRuleScopeId (LOOK_AHEAD(2) "," DynRuleScopeId)* ;

TrafoSortList :
	TrafoSort (LOOK_AHEAD(2) "," TrafoSort)* ;
