
options {
  STATIC = false;
}

PARSER_BEGIN(PHaskellParser)

package tmp.generated_phaskell;

import java.io.*;
import java.util.*;
import cide.gast.*;
import cide.gparser.*;
import de.ovgu.cide.fstgen.ast.AbstractFSTParser;

  public class PHaskellParser  extends AbstractFSTParser {

	/**
	 * Append the given {@link Token} and any preceding special tokens to a
	 * given {@link StringBuffer}.
	 * 
	 * @param token
	 *            the given JavaCC {@link Token} object
	 * @param buffer
	 *            the buffer to which to append <code>token</code>
	 */
	final private static void accumulate(Token token, StringBuffer buffer) {

		// Append preceding special tokens to <code>buffer</code>:
		//
		Token special = firstSpecial(token);
		if (special != token)
			while (special != null) {
				buffer.append(special.toString());
				special = special.next;
			}

		// Finally, append the token itself:
		//
		buffer.append(token.toString());
	}

	/**
	 * Accumulate {@list Token} objects from the token stream, respecting nested
	 * code inside <code>open</code> and <code>close</code> pairs, until an
	 * unmatched <code>close</code> is the next token in the stream. This
	 * method assumes that an <code>open</code> token has just been read from
	 * the stream so the initial nesting level is 1. The method returns when a
	 * matching <code>close</code> token is the next token in the token
	 * stream. <em>The <code>close</code> token is left in the stream!</em>
	 * 
	 * @return the accumulated tokens as a {@link String}.
	 * 
	 * @throws ParseException
	 *             if an end-of-file is found before an unmatched
	 *             <code>close</code> token.
	 */
	final private Token accumulateNestedRegion(int open, int close)
			throws ParseException {

		StringBuffer buffer = new StringBuffer();
		Token token = getToken(1);

		// Initialize result with known information (starting position, etc.):
		//
		Token result = Token.newToken(UNANTICIPATED_SYMBOL);
		result.specialToken = null;

		Token startToken = firstSpecial(token);
		result.beginColumn = startToken.beginColumn;
		result.beginLine = startToken.beginLine;
		result.offset=startToken.offset;

		// Accumulate tokens until a <code>close</code> token is found:
		//
		for (int nesting = 1; nesting > 0;) {


			if (token.kind == EOF)
				throw new ParseException("accumulating from line "
						+ result.beginLine + " at column " + result.beginColumn
						+ ": EOF reached before ending " + tokenImage[close]
						+ " found");

			if (token.kind == open)
				++nesting;
			else if (token.kind == close) {
				if (nesting == 1)
					break;
				--nesting;
			}

			// Update information in result:
			//
			result.endColumn = token.endColumn;
			result.endLine = token.endLine;
			result.length=(token.offset-result.offset)+token.length;
			result.next = token.next;

			accumulate(token, buffer);
			getNextToken();
			token = getToken(1);
		}

		result.image = buffer.toString();
		return result;
	}


	final private Token accumulateUntil(boolean considerInnerBlocks,
			int endTokenKind) throws ParseException {
		return accumulateUntil(considerInnerBlocks, new int[] { endTokenKind });
	}

	final private Token accumulateUntil(boolean considerInnerBlocks,
			int endTokenKind1, int endTokenKind2) throws ParseException {
		return accumulateUntil(considerInnerBlocks, new int[] { endTokenKind1,
				endTokenKind2 });
	}

	final private Token accumulateUntil(boolean considerInnerBlocks,
			int endTokenKind1, int endTokenKind2, int endTokenKind3)
			throws ParseException {
		return accumulateUntil(considerInnerBlocks, new int[] { endTokenKind1,
				endTokenKind2, endTokenKind3 });
	}
	final private Token accumulateUntil(boolean considerInnerBlocks,
			int endTokenKind1, int endTokenKind2, int endTokenKind3, int endTokenKind4)
			throws ParseException {
		return accumulateUntil(considerInnerBlocks, new int[] { endTokenKind1,
				endTokenKind2, endTokenKind3, endTokenKind4 });
	}

	final private boolean isNot(int kind) {
		return getToken(1).kind != kind;
	}

	final private boolean isNot(int k1, int k2) {
		return isNot(k1) && isNot(k2);
	}

	final private boolean isNot(int k1, int k2, int k3) {
		return isNot(k1, k2) && isNot(k3);
	}
	final private boolean isNot(int k1, int k2, int k3, int k4) {
		return isNot(k1, k2, k3) && isNot(k4);
	}
	
	/** returns true if the CONTEXT_ARROW is found before the SEMICOLON **/
	final private boolean isContext() throws ParseException {
		int lookahead=1;
		while (true) {
			Token t = getToken(lookahead);
			if (t.kind==EOF) throw new ParseException("EOF found before ; or =>  (line " + token.beginLine
                                                + ", column " + token.beginColumn
                                                + ")");
			if (t.kind==SEMICOLON) return false;
			if (t.kind==CONTEXT_ARROW) return true;	
			lookahead++;
		}
	}

	/**
	 * Accumulate {@link Token} objects from the token stream until a token
	 * matching <code>tokenKind</code> is consumed from the stream. The tokens
	 * are accumulated in <code>buffer</code>, NOT including the terminating
	 * token.
	 * 
	 * @return a {@link Token} formed by concatenating all intervening tokens
	 *         and special tokens.
	 */
	final private Token accumulateUntil(boolean considerInnerBlocks,
			int[] endTokenKinds) throws ParseException {

		StringBuffer buffer = new StringBuffer();
		Token token = getToken(1);

		// Initialize result with known information (starting position, etc.):
		//
		Token result = Token.newToken(UNANTICIPATED_SYMBOL);
		result.specialToken = null;

		Token startToken = firstSpecial(token);
		result.beginColumn = startToken.beginColumn;
		result.beginLine = startToken.beginLine;
		result.offset=startToken.offset;

		// Accumulate tokens until a <code>tokenKind</code> token is found:
		//
		int nesting=0;
		while (!contains(endTokenKinds, token.kind) || nesting >0) {
			// Update information in result:
			//
			result.endColumn = token.endColumn;
			result.endLine = token.endLine;
			result.next = token.next;
			result.length=(token.offset-result.offset)+token.length;

			if (token.kind == EOF)
				throw new ParseException("from line " + result.beginLine
						+ " at column " + result.beginColumn
						+ ": EOF reached before " + images(endTokenKinds)
						+ " found");
			
			if (considerInnerBlocks && token.kind == LEFT_CURLY)
				++nesting;
			else if (considerInnerBlocks && token.kind == RIGHT_CURLY) {
				--nesting;
			}

			accumulate(token, buffer);
			getNextToken();
			token = getToken(1);
		}

		if (buffer.length() == 0)
			throw new ParseException("syntax error - empty pseudo-match (line " + result.beginLine
                                                + ", column " + result.beginColumn
                                                + ")");

		result.image = buffer.toString();
		return result;
	}

	private String images(int[] endTokenKinds) {
		String result = "";
		for (int i : endTokenKinds)
			result += tokenImage[i] + " ";
		return result;
	}

	private boolean contains(int[] endTokenKinds, int kind) {
		for (int i : endTokenKinds)
			if (i == kind)
				return true;
		return false;
	}

    /**
     * Finds the first token, special or otherwise, in the list of special
     * tokens preceding this {@link Token}.  If this list is non-empty, the
     * result will be a special token.  Otherwise, it will be the starting
     * token.
     *
     * @param token the given {@link Token}.
     * @return the first special token preceding <code>token</code>.
     **/
    final private static Token firstSpecial (Token token) {

	while (token.specialToken != null)
	    token = token.specialToken ;

	return token ;
    }
  }

PARSER_END(PHaskellParser)


JAVACODE
Token findListContent () {
    return accumulateNestedRegion(LEFT_PAREN, RIGHT_PAREN) ;
}

JAVACODE
Token findBlockContent () {
    return accumulateNestedRegion (LEFT_CURLY, RIGHT_CURLY) ;
}

JAVACODE
Token findConRest () {
	//(block | ~(SEMICOLON|ALT|RIGHT_CURLY))*
    return accumulateUntil(true,SEMICOLON,ALT,RIGHT_CURLY,DERIVING) ;
}

JAVACODE
Token findNonstddeclRest () {
	//(block | ~(SEMICOLON|RIGHT_CURLY))+
    return accumulateUntil(true,SEMICOLON,RIGHT_CURLY) ;
}

JAVACODE
Token findUntilSemiOrCCB () {
	//~(SEMICOLON | RIGHT_CURLY)*
    return accumulateUntil(false,SEMICOLON,RIGHT_CURLY) ;
}
JAVACODE
Token findUntilSemiOrContextArrow () {
	//(~(CONTEXT_ARROW|SEMICOLON))*;
    return accumulateUntil(false,CONTEXT_ARROW,SEMICOLON) ;
}
JAVACODE
Token findUntilSemiOrEquals () {
	//~(EQUALS|SEMICOLON))*
    return accumulateUntil(false,SEMICOLON,EQUALS) ;
}
JAVACODE
Token findUntilEquals () {
	//~(EQUALS))*
    return accumulateUntil(false,EQUALS) ;
}





//options	{
//    k = 9;
//    // Allow any char but \uFFFF (16 bit -1)
//    charVocabulary='\u0000'..'\uFFFE';
//}

TOKEN : {
	<MODULE : "module">
|	<WHERE : "where" >
|	<IMPORT : "import" >
|	<QUALIFIED : "qualified" >
|	<DERIVING : "deriving" >
|	<AS : "as" >
|	<HIDING : "hiding" >
|	<TYPE : "type" >
|	<DATA : "data" >
|	<NEWTYPE : "newtype" >
|	<CLASS : "class" >
|	<INSTANCE : "instance" >
|	<DEFAULTTOKEN : "default" >
|	<LET : "let" >
|	<DO : "do" >
|	<OF : "of" >
|	<INFIXL : "infixl" >
|	<INFIXR : "infixr" >
|	<INFIX : "infix" >
|	<CONTEXT_ARROW : "=>" >
|	<EQUALS : "=" >
|	<ALT : "|" >
|	<OFTYPE : "::" >
//|	<QVARID>//|	<QCONID>//|	<QVARSYM>
}

SPECIAL_TOKEN : {
 " "
|  "\t"
|  "\n"
|  "\r"
|  <"--" (~["\n","\r"])* ("\n" | "\r" | "\r\n")>
| <"{-"(~["-"])*"-"("-" | ~["-", "}"](~["-"])*"-")*"}">
}

    
//PPDIRECTIVE
//	:	'#' (~('\n'))* NEWLINE { $setType(Token.SKIP); }
//	;


TOKEN : {
	<CONSTRUCTOR_ID : <UPPER_CASE>	( <LETTER>
							| <DIGIT>
							| "'" )* >
|	<VARIABLE_ID : <LOWER_CASE>	( <LETTER>
							| <DIGIT>
							| "'" )*>

|	<INTEGER:	(<DECIMAL>	|	"0o" <OCTAL> | "0O" <OCTAL>
		|	"0x" <HEXADECIMAL> | "0X" <HEXADECIMAL>)>
		

|	<#DECIMAL : (<DIGIT>)+ >

|	<#HEXADECIMAL : (<HEXIT>)+>

|	<#OCTAL : (<OCTIT>)+ >

//|	<CHARACTER_LITERAL : "'" (~["'","\\"]|<CHARACTER_ESCAPE>) "'" >////|	<STRING_LITERAL : "\"" (~["\"","\\"]|<STRING_ESCAPE>|<GAP>)* "\"" >
|  < CHARACTER_LITERAL:
      "'"
      (   (~["'","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            )
          )
      )
      "'"
  >
|
  < STRING_LITERAL:
      "\""
      (   (~["\"","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            )
          )
      )*
      "\""
  >
|	<#CHARACTER_ESCAPE	:	"\\"
		( <CHAR_ESC>
		| <ASCII>
		| <DECIMAL>
		| "x" <HEXADECIMAL>
		| "o" <OCTAL>
		)
	>
	
|	<CHAR_ESC
	:
    	( "a"
    	| "b"  
    	| "f"  
    	| "n"  
    	| "r" 
    	| "t" 
    	| "v"
    	| "\\" 
    	| "\""
    	| "\'" )
	>

|	<#STRING_ESCAPE	: ("\\&" | <CHARACTER_ESCAPE>)>
    
    
|	<#ASCII : "NUL" >
    
//|	<NEWLINE : "\n">

//|	<#GAP : "\\" (<WS> | <NEWLINE>)+ "\\" >

|	<#LOWER_CASE:	["a"-"z","_"]>	
|	<#UPPER_CASE:	["A"-"Z"]>	
|	<#LETTER : <UPPER_CASE> | <LOWER_CASE>>

|	<#DIGIT:	["0"-"9"]>	

|	<#HEXIT:	(<DIGIT> | ["A"-"F"] | ["a"-"f"] )>	

|	<#OCTIT:	["0"-"7"]>	

|	<LEFT_CURLY : "{" >

|	<RIGHT_CURLY : "}" >

|	<SEMICOLON : ";" >

|	<LEFT_PAREN : "(" >

|	<RIGHT_PAREN : ")" >

|	<LEFT_BRACKET : "[" >

|	<RIGHT_BRACKET : "]" >

|	<COMMA : "," >

|	<INFIX_QUOTE : "`" >

|	<VARSYM : <SYMBOL> (<SYMBOL> | ":" )* >

|	<CONSYM : ":" (<SYMBOL> | ":" )* >

|	<SYMBOL : "!" | "#" | "$" | "%" | "&" | "*" | "+" | "." | "/" | "<" | "="
       | ">" | "?" | "@" | "\\" | "^" | "-" | "~" | "|"
       >
       
|	<UNANTICIPATED_SYMBOL : ~["a"-"z","A"-"Z","0"-"9"] >
}


<PAREN> TOKEN :{
 	<ANYTHINGP: ~["(",")"]>
}
FSTInfo module(boolean inTerminal) : { Token first=null,t;FSTInfo n; 
} { {first=getToken(1); productionStart(inTerminal); } (
	"module" n=modid(inTerminal){ replaceName("modid", n);}{ replaceName(n);} [n=exports(inTerminal){ replaceName(n);}] "where" n=body(inTerminal){ replaceName(n);} <EOF> {return productionEndNonTerminal("module","{modid}","{modid}");}

 )  }

FSTInfo qconid(boolean inTerminal) : { Token first=null,t;FSTInfo n; 
} { {first=getToken(1); productionStart(inTerminal); } (
	<CONSTRUCTOR_ID> {return productionEndTerminal("qconid","{TOSTRING}","{TOSTRING}","Replacement",first,token);}

 )  }

FSTInfo exports(boolean inTerminal) : { Token first=null,t;FSTInfo n; 
} { {first=getToken(1); productionStart(inTerminal); } (
	"(" [n=exportsList(true){ replaceName(n);}] ["," ] ")" {return productionEndTerminal("exports","-","-","Replacement",first,token);}

 )  }

FSTInfo exportsList(boolean inTerminal) : { Token first=null,t;FSTInfo n; 
} { {first=getToken(1); productionStart(inTerminal); } (
	n=export(true){ replaceName(n);} (LOOKAHEAD(2) "," n=export(true){ replaceName(n);})* {return productionEndTerminal("exportsList","-","-","Replacement",first,token);}

 )  }

FSTInfo export(boolean inTerminal) : { Token first=null,t;FSTInfo n; 
} { {first=getToken(1); productionStart(inTerminal); } (
	n=qvar(true){ replaceName(n);} {return productionEndTerminal("export1","-","-","Replacement",first,token);}
 |
	n=qtyconorcls(true){ replaceName(n);} [n=details(true){ replaceName(n);}] {return productionEndTerminal("export2","-","-","Replacement",first,token);}
 |
	"module" n=modid(true){ replaceName(n);} {return productionEndTerminal("export3","-","-","Replacement",first,token);}

 )  }

FSTInfo details(boolean inTerminal) : { Token first=null,t;FSTInfo n; 
} { {first=getToken(1); productionStart(inTerminal); } (
	LOOKAHEAD(2) "(" <VARSYM> ")"  {return productionEndTerminal("details1","-","-","Replacement",first,token);}
 |
	"(" [n=cnamelist(true){ replaceName(n);}] ")" {return productionEndTerminal("details2","-","-","Replacement",first,token);}

 )  }

FSTInfo cnamelist(boolean inTerminal) : { Token first=null,t;FSTInfo n; 
} { {first=getToken(1); productionStart(inTerminal); } (
	n=cname(true){ replaceName(n);} ("," n=cname(true){ replaceName(n);})* {return productionEndTerminal("cnamelist","-","-","Replacement",first,token);}

 )  }

FSTInfo qtyconorcls(boolean inTerminal) : { Token first=null,t;FSTInfo n; 
} { {first=getToken(1); productionStart(inTerminal); } (
	n=qconid(true){ replaceName(n);} {return productionEndTerminal("qtyconorcls","-","-","Replacement",first,token);}

 )  }

FSTInfo cname(boolean inTerminal) : { Token first=null,t;FSTInfo n; 
} { {first=getToken(1); productionStart(inTerminal); } (
	<VARIABLE_ID> {return productionEndTerminal("cname1","-","-","Replacement",first,token);}
 |
	<CONSTRUCTOR_ID> {return productionEndTerminal("cname2","-","-","Replacement",first,token);}

 )  }

FSTInfo qvar(boolean inTerminal) : { Token first=null,t;FSTInfo n; 
} { {first=getToken(1); productionStart(inTerminal); } (
	n=qvarid(true){ replaceName(n);} {return productionEndTerminal("qvar1","-","-","Replacement",first,token);}
 |
	"(" n=qvarsym(true){ replaceName(n);} ")" {return productionEndTerminal("qvar2","-","-","Replacement",first,token);}

 )  }

FSTInfo qvarid(boolean inTerminal) : { Token first=null,t;FSTInfo n; 
} { {first=getToken(1); productionStart(inTerminal); } (
	<VARIABLE_ID> {return productionEndTerminal("qvarid","-","-","Replacement",first,token);}

 )  }

FSTInfo qvarsym(boolean inTerminal) : { Token first=null,t;FSTInfo n; 
} { {first=getToken(1); productionStart(inTerminal); } (
	<VARSYM> {return productionEndTerminal("qvarsym","-","-","Replacement",first,token);}

 )  }

FSTInfo modid(boolean inTerminal) : { Token first=null,t;FSTInfo n; 
} { {first=getToken(1); productionStart(inTerminal); } (
	n=qconid(true){ replaceName(n);} {return productionEndTerminal("modid","{TOSTRING}","{TOSTRING}","Replacement",first,token);}

 )  }

FSTInfo conid(boolean inTerminal) : { Token first=null,t;FSTInfo n; 
} { {first=getToken(1); productionStart(inTerminal); } (
	<CONSTRUCTOR_ID> {return productionEndTerminal("conid","{TOSTRING}","{TOSTRING}","Replacement",first,token);}

 )  }

FSTInfo body(boolean inTerminal) : { Token first=null,t;FSTInfo n; 
} { {first=getToken(1); productionStart(inTerminal); } (
	LOOKAHEAD(2) "{" n=impdecls(inTerminal){ replaceName(n);} [";" n=topdecls(inTerminal){ replaceName(n);}] "}" {return productionEndNonTerminal("body1","-","-");}
 |
	"{" n=topdecls(inTerminal){ replaceName(n);} "}" {return productionEndNonTerminal("body2","-","-");}

 )  }

FSTInfo impdecls(boolean inTerminal) : { Token first=null,t;FSTInfo n; 
} { {first=getToken(1); productionStart(inTerminal); } (
	n=impdecl(true){ replaceName(n);} (LOOKAHEAD(2) ";" n=impdecl(true){ replaceName(n);})* {return productionEndTerminal("impdecls","-","-","Replacement",first,token);}

 )  }

FSTInfo impdecl(boolean inTerminal) : { Token first=null,t;FSTInfo n; 
} { {first=getToken(1); productionStart(inTerminal); } (
	"import" ["qualified" ] n=modid(true){ replaceName(n);} ["as" n=modid(true){ replaceName(n);}] [n=impspec(true){ replaceName(n);}] {return productionEndTerminal("impdecl1","-","-","Replacement",first,token);}
 |
	 {return productionEndTerminal("impdecl2","-","-","Replacement",first,token);}

 )  }

FSTInfo impspec(boolean inTerminal) : { Token first=null,t;FSTInfo n; 
} { {first=getToken(1); productionStart(inTerminal); } (
	["hiding" ] "(" [n=imports(true){ replaceName(n);}] ")" {return productionEndTerminal("impspec","-","-","Replacement",first,token);}

 )  }

FSTInfo imports(boolean inTerminal) : { Token first=null,t;FSTInfo n; 
} { {first=getToken(1); productionStart(inTerminal); } (
	n=imp(true){ replaceName(n);} (LOOKAHEAD("," imp()) "," n=imp(true){ replaceName(n);})* {return productionEndTerminal("imports","-","-","Replacement",first,token);}

 )  }

FSTInfo imp(boolean inTerminal) : { Token first=null,t;FSTInfo n; 
} { {first=getToken(1); productionStart(inTerminal); } (
	n=var(true){ replaceName(n);} {return productionEndTerminal("imp1","-","-","Replacement",first,token);}
 |
	n=tyconorcls(true){ replaceName(n);} [n=list(true){ replaceName(n);}] {return productionEndTerminal("imp2","-","-","Replacement",first,token);}

 )  }

FSTInfo tyconorcls(boolean inTerminal) : { Token first=null,t;FSTInfo n; 
} { {first=getToken(1); productionStart(inTerminal); } (
	n=conid(true){ replaceName(n);} {return productionEndTerminal("tyconorcls","-","-","Replacement",first,token);}

 )  }

FSTInfo topdecls(boolean inTerminal) : { Token first=null,t;FSTInfo n; 
} { {first=getToken(1); productionStart(inTerminal); } (
	n=topdecl(inTerminal){ replaceName(n);} (";" n=topdecl(inTerminal){ replaceName(n);})* {return productionEndNonTerminal("topdecls","-","-");}

 )  }

FSTInfo topdecl(boolean inTerminal) : { Token first=null,t;FSTInfo n; 
} { {first=getToken(1); productionStart(inTerminal); } (
	"type" n=simpletype(inTerminal){ replaceName("simpletype", n);}{ replaceName(n);} n=declrhs(inTerminal){ replaceName(n);} {return productionEndNonTerminal("typedecl","{simpletype}","{simpletype}");}
 |
	"data" n=optContext(inTerminal){ replaceName(n);} n=simpletype(inTerminal){ replaceName("simpletype", n);}{ replaceName(n);} "=" n=constrs(inTerminal){ replaceName(n);} [n=deriving(inTerminal){ replaceName(n);}] {return productionEndNonTerminal("datadecl","{simpletype}","{simpletype}");}
 |
	"newtype" n=optContext(inTerminal){ replaceName(n);} n=simpletype(inTerminal){ replaceName("simpletype", n);}{ replaceName(n);} n=declrhs(inTerminal){ replaceName(n);} {return productionEndNonTerminal("newtypedecl","{simpletype}","{simpletype}");}
 |
	"class" n=optContext(inTerminal){ replaceName(n);} n=conid(inTerminal){ replaceName("conid", n);}{ replaceName(n);} n=tyvar(inTerminal){ replaceName(n);} ["where" n=cdecls(inTerminal){ replaceName(n);}] {return productionEndNonTerminal("classdecl","{conid}","{conid}");}
 |
	"instance" n=optContext(inTerminal){ replaceName(n);} n=qconid(inTerminal){ replaceName("qconid", n);}{ replaceName(n);} n=inst(inTerminal){ replaceName(n);} ["where" n=block(inTerminal){ replaceName(n);}] {return productionEndNonTerminal("instancedecl","{qconid}","{qconid}");}
 |
	"default" n=list(true){ replaceName(n);} {return productionEndTerminal("defaultdecl","-","-","Replacement",first,token);}
 |
	n=decl(true){ replaceName(n);} {return productionEndTerminal("declaration","{TOSTRING}","{TOSTRING}","Replacement",first,token);}

 )  }

FSTInfo decl(boolean inTerminal) : { Token first=null,t;FSTInfo n; 
} { {first=getToken(1); productionStart(inTerminal); } (
	LOOKAHEAD(vars() "::") n=signdecl(true){ replaceName(n);} {return productionEndTerminal("typeSignature","-","-","Replacement",first,token);}
 |
	n=fixdecl(true){ replaceName(n);} {return productionEndTerminal("fixityDeclaration","-","-","Replacement",first,token);}
 |
	LOOKAHEAD(funlhs() "=") n=valdef(true){ replaceName(n);} {return productionEndTerminal("valueDeclaration","-","-","Replacement",first,token);}
 |
	n=nonstddecl(true){ replaceName(n);} {return productionEndTerminal("nonStandardDeclaration","-","-","Replacement",first,token);}
 |
	 {return productionEndTerminal("decl5","-","-","Replacement",first,token);}

 )  }

FSTInfo declrhs(boolean inTerminal) : { Token first=null,t;FSTInfo n; 
} { {first=getToken(1); productionStart(inTerminal); } (
	"=" [LOOKAHEAD({isNot(SEMICOLON,RIGHT_CURLY)}) findNonstddeclRest()] {return productionEndTerminal("declrhs","-","-","Replacement",first,token);}

 )  }

FSTInfo optContext(boolean inTerminal) : { Token first=null,t;FSTInfo n; 
} { {first=getToken(1); productionStart(inTerminal); } (
	[LOOKAHEAD({isContext()}) n=context(true){ replaceName(n);} "=>"] {return productionEndTerminal("optContext","-","-","Replacement",first,token);}

 )  }

FSTInfo deriving(boolean inTerminal) : { Token first=null,t;FSTInfo n; 
} { {first=getToken(1); productionStart(inTerminal); } (
	"deriving" findNonstddeclRest() {return productionEndTerminal("deriving","-","-","Replacement",first,token);}

 )  }

FSTInfo constrs(boolean inTerminal) : { Token first=null,t;FSTInfo n; 
} { {first=getToken(1); productionStart(inTerminal); } (
	n=constr(inTerminal){ replaceName(n);} ("|" n=constr(inTerminal){ replaceName(n);})* {return productionEndNonTerminal("constrs","-","-");}

 )  }

FSTInfo constr(boolean inTerminal) : { Token first=null,t;FSTInfo n; 
} { {first=getToken(1); productionStart(inTerminal); } (
	n=conP(true){ replaceName(n);} [LOOKAHEAD({isNot(SEMICOLON,ALT,RIGHT_CURLY,DERIVING)}) findConRest()] {return productionEndTerminal("constr","{TOSTRING}","{TOSTRING}","Replacement",first,token);}

 )  }

FSTInfo inst(boolean inTerminal) : { Token first=null,t;FSTInfo n; 
} { {first=getToken(1); productionStart(inTerminal); } (
	n=gtycon(true){ replaceName(n);} {return productionEndTerminal("inst1","-","-","Replacement",first,token);}
 |
	"(" n=gtycon(true){ replaceName(n);} (n=tyvar(true){ replaceName(n);})* ")" {return productionEndTerminal("inst2","-","-","Replacement",first,token);}
 |
	"[" n=conid(true){ replaceName(n);} "]" {return productionEndTerminal("inst3","-","-","Replacement",first,token);}

 )  }

FSTInfo gtycon(boolean inTerminal) : { Token first=null,t;FSTInfo n; 
} { {first=getToken(1); productionStart(inTerminal); } (
	n=qtyconorcls(true){ replaceName(n);} {return productionEndTerminal("gtycon","-","-","Replacement",first,token);}

 )  }

FSTInfo cdecls(boolean inTerminal) : { Token first=null,t;FSTInfo n; 
} { {first=getToken(1); productionStart(inTerminal); } (
	"{" [n=cdeclsI(true){ replaceName(n);}] "}" {return productionEndTerminal("cdecls","-","-","Replacement",first,token);}

 )  }

FSTInfo cdeclsI(boolean inTerminal) : { Token first=null,t;FSTInfo n; 
} { {first=getToken(1); productionStart(inTerminal); } (
	n=cdecl(true){ replaceName(n);} (";" n=cdecl(true){ replaceName(n);})* {return productionEndTerminal("cdeclsI","-","-","Replacement",first,token);}

 )  }

FSTInfo cdecl(boolean inTerminal) : { Token first=null,t;FSTInfo n; 
} { {first=getToken(1); productionStart(inTerminal); } (
	LOOKAHEAD(vars() "::") n=signdecl(true){ replaceName(n);} {return productionEndTerminal("cdecl1","-","-","Replacement",first,token);}
 |
	n=nonstddecl(true){ replaceName(n);} {return productionEndTerminal("cdecl2","-","-","Replacement",first,token);}

 )  }

FSTInfo context(boolean inTerminal) : { Token first=null,t;FSTInfo n; 
} { {first=getToken(1); productionStart(inTerminal); } (
	[LOOKAHEAD({isNot(SEMICOLON,CONTEXT_ARROW)}) findUntilSemiOrContextArrow()] {return productionEndTerminal("context","-","-","Replacement",first,token);}

 )  }

FSTInfo simpletype(boolean inTerminal) : { Token first=null,t;FSTInfo n; 
} { {first=getToken(1); productionStart(inTerminal); } (
	<CONSTRUCTOR_ID> [LOOKAHEAD({isNot(EQUALS)}) findUntilEquals()] {return productionEndTerminal("simpletype","{TOSTRING}","{TOSTRING}","Replacement",first,token);}

 )  }

FSTInfo nonstddecl(boolean inTerminal) : { Token first=null,t;FSTInfo n; 
} { {first=getToken(1); productionStart(inTerminal); } (
	findNonstddeclRest() {return productionEndTerminal("nonstddecl","-","-","Replacement",first,token);}

 )  }

FSTInfo valdef(boolean inTerminal) : { Token first=null,t;FSTInfo n; 
} { {first=getToken(1); productionStart(inTerminal); } (
	n=funlhs(true){ replaceName(n);} n=declrhs(true){ replaceName(n);} {return productionEndTerminal("valdef","-","-","Replacement",first,token);}

 )  }

FSTInfo fixdecl(boolean inTerminal) : { Token first=null,t;FSTInfo n; 
} { {first=getToken(1); productionStart(inTerminal); } (
	n=fixity(true){ replaceName(n);} [<INTEGER>] n=ops(true){ replaceName(n);} {return productionEndTerminal("fixdecl","-","-","Replacement",first,token);}

 )  }

FSTInfo fixity(boolean inTerminal) : { Token first=null,t;FSTInfo n; 
} { {first=getToken(1); productionStart(inTerminal); } (
	"infixl"  {return productionEndTerminal("fixity1","-","-","Replacement",first,token);}
 |
	"infixr"  {return productionEndTerminal("fixity2","-","-","Replacement",first,token);}
 |
	"infix"  {return productionEndTerminal("fixity3","-","-","Replacement",first,token);}

 )  }

FSTInfo ops(boolean inTerminal) : { Token first=null,t;FSTInfo n; 
} { {first=getToken(1); productionStart(inTerminal); } (
	n=op(true){ replaceName(n);} ("," n=op(true){ replaceName(n);})* {return productionEndTerminal("ops","-","-","Replacement",first,token);}

 )  }

FSTInfo signdecl(boolean inTerminal) : { Token first=null,t;FSTInfo n; 
} { {first=getToken(1); productionStart(inTerminal); } (
	n=vars(true){ replaceName(n);} "::" [LOOKAHEAD({isNot(SEMICOLON,RIGHT_CURLY)}) findUntilSemiOrCCB()] {return productionEndTerminal("signdecl","-","-","Replacement",first,token);}

 )  }

FSTInfo vars(boolean inTerminal) : { Token first=null,t;FSTInfo n; 
} { {first=getToken(1); productionStart(inTerminal); } (
	n=var(true){ replaceName(n);} ("," n=var(true){ replaceName(n);})* {return productionEndTerminal("vars","-","-","Replacement",first,token);}

 )  }

FSTInfo var(boolean inTerminal) : { Token first=null,t;FSTInfo n; 
} { {first=getToken(1); productionStart(inTerminal); } (
	<VARIABLE_ID> {return productionEndTerminal("var1","-","-","Replacement",first,token);}
 |
	"(" <VARSYM> ")" {return productionEndTerminal("var2","-","-","Replacement",first,token);}

 )  }

FSTInfo conP(boolean inTerminal) : { Token first=null,t;FSTInfo n; 
} { {first=getToken(1); productionStart(inTerminal); } (
	<CONSTRUCTOR_ID> {return productionEndTerminal("conP1","-","-","Replacement",first,token);}
 |
	"(" <CONSYM> ")" {return productionEndTerminal("conP2","-","-","Replacement",first,token);}

 )  }

FSTInfo tyvar(boolean inTerminal) : { Token first=null,t;FSTInfo n; 
} { {first=getToken(1); productionStart(inTerminal); } (
	<VARIABLE_ID> {return productionEndTerminal("tyvar","-","-","Replacement",first,token);}

 )  }

FSTInfo funlhs(boolean inTerminal) : { Token first=null,t;FSTInfo n; 
} { {first=getToken(1); productionStart(inTerminal); } (
	n=funlhsL(true){ replaceName(n);} [LOOKAHEAD({isNot(SEMICOLON,EQUALS,LEFT_CURLY)}) n=funlhsR(true){ replaceName(n);}] {return productionEndTerminal("funlhs","-","-","Replacement",first,token);}

 )  }

FSTInfo funlhsL(boolean inTerminal) : { Token first=null,t;FSTInfo n; 
} { {first=getToken(1); productionStart(inTerminal); } (
	LOOKAHEAD(<VARIABLE_ID> varop()) <VARIABLE_ID> n=varop(true){ replaceName(n);} {return productionEndTerminal("funlhsL1","-","-","Replacement",first,token);}
 |
	n=var(true){ replaceName(n);} {return productionEndTerminal("funlhsL2","-","-","Replacement",first,token);}

 )  }

FSTInfo funlhsR(boolean inTerminal) : { Token first=null,t;FSTInfo n; 
} { {first=getToken(1); productionStart(inTerminal); } (
	n=block(true){ replaceName(n);} {return productionEndTerminal("funlhsR1","-","-","Replacement",first,token);}
 |
	LOOKAHEAD({isNot(SEMICOLON,EQUALS)}) findUntilSemiOrEquals() {return productionEndTerminal("funlhsR2","-","-","Replacement",first,token);}

 )  }

FSTInfo varop(boolean inTerminal) : { Token first=null,t;FSTInfo n; 
} { {first=getToken(1); productionStart(inTerminal); } (
	<VARSYM> {return productionEndTerminal("varop1","-","-","Replacement",first,token);}
 |
	"`" <VARIABLE_ID> "`" {return productionEndTerminal("varop2","-","-","Replacement",first,token);}

 )  }

FSTInfo conop(boolean inTerminal) : { Token first=null,t;FSTInfo n; 
} { {first=getToken(1); productionStart(inTerminal); } (
	<CONSYM> {return productionEndTerminal("conop1","-","-","Replacement",first,token);}
 |
	"`" <CONSTRUCTOR_ID> "`" {return productionEndTerminal("conop2","-","-","Replacement",first,token);}

 )  }

FSTInfo op(boolean inTerminal) : { Token first=null,t;FSTInfo n; 
} { {first=getToken(1); productionStart(inTerminal); } (
	LOOKAHEAD(2) n=varop(true){ replaceName(n);} {return productionEndTerminal("op1","-","-","Replacement",first,token);}
 |
	n=conop(true){ replaceName(n);} {return productionEndTerminal("op2","-","-","Replacement",first,token);}

 )  }

FSTInfo block(boolean inTerminal) : { Token first=null,t;FSTInfo n; 
} { {first=getToken(1); productionStart(inTerminal); } (
	"{" [LOOKAHEAD({isNot(RIGHT_CURLY)}) findBlockContent()] "}" {return productionEndTerminal("block","-","-","Replacement",first,token);}

 )  }

FSTInfo list(boolean inTerminal) : { Token first=null,t;FSTInfo n; 
} { {first=getToken(1); productionStart(inTerminal); } (
	"(" [LOOKAHEAD({isNot(RIGHT_PAREN)}) findListContent()] ")" {return productionEndTerminal("list","-","-","Replacement",first,token);}

 )  }

