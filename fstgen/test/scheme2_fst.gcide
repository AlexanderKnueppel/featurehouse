options {
  STATIC = false;
}

PARSER_BEGIN(Scheme2Parser)

package tmp.generated_scheme2;

import java.io.*;
import java.util.*;
import cide.gast.*;
import cide.gparser.*;
import de.ovgu.cide.fstgen.ast.AbstractFSTParser;

public class Scheme2Parser extends AbstractFSTParser {

}

PARSER_END(Scheme2Parser)

TOKEN : {
	<plus			: "+">
|	<minus			: "-" >
|	<excl			: "!" >
|	<dollar			: "$" >
|	<perc			: "%" >
|	<and			: "&" >
|	<mult			: "*" >
| 	<div			: "/" >
|	<colon			: ":" >
|	<less			: "<" >
|	<eq				: "=" >
|	<great			: ">" >
|	<quest			: "?" >
|	<tilde			: "~" >
|	<uline			: "_" >
|	<power			: "^" >
|	<dot			: "." >
|	<egt			: "=>" >
|	<begin			: "begin" >
|	<let			: "let" >
|	<letrec			: "letrec" >
|	<define 		: "define" >
|	<quote 			: "quote" >
|	<lambda			: "lambda" > 
|	<iff 			: "if" >
|	<set 			: "set!" >
|	<dotok 			: "do" >
|	<ortok 			: "or" >
|	<andtok 		: "and" >
|	<condtok		: "cond" >
|	<elsetok		: "else" >
|	<casetok		: "case" >
|	<delaytok		: "delay" >
|	<truetoken		: "#t" >
|	<falsetoken		: "#f" >
|	<prime1			: "'" >
| 	<prime2			: "`" >
|	<comma			: "," >
|	<commaat		: ",@">
|	<at				: "@">
}

SPECIAL_TOKEN : {
" "
|  "\t"
|  "\n"
|  "\r"
|  <"--" (~["\n","\r"])* ("\n" | "\r" | "\r\n")>
| <"{-"(~["-"])*"-"("-" | ~["-", "}"](~["-"])*"-")*"}">
}

TOKEN : {

<identifier	:	<initial> (<subsequent>)* 
				| <plus>  
				| <minus>
				| "..."
				>			
|				
<#initial	:	<letter>
			|	<operator>
			>
|			
<#operator	:	<excl>
			|	<dollar>
			|	<perc>
			|	<and>
			|	<mult> 
			| 	<div>
			|	<colon>
			|	<less>
			|	<eq>
			|	<great>
			|	<quest>
			|	<tilde>
			|	<uline>
			|	<power>
			>

|
<#subsequent	:	<initial>
			|	<digit>
			| 	<dot>
			|	<plus>
			|	<minus>
			>

|
<#letter	:	["a"-"z"]
		|	["A"-"Z"]
		>
|		
<bool	:	"#" ["t","f","T","F"]>
|
<number	:	<num> >
|
<character	:	"#\\" ~[]
			|	"\\" ["n"," "]
			>
|
<string	:	"\"" (<string_character>)* "\""	>
|		
<#string_character	:	"\""
					|	"\\"
					|	~["\\","\""]
					>
|		
<#num	:	<prefix> <complex> >
|
<#complex	:	<real>
			|	<real> <at> <real>
			|	<real> <plus> <imag>
			|	<real> <minus> <imag>
			|	<plus> <imag> 
			|	<minus> <imag>
			>
|			
<#imag	:	"i"	| <ureal> "i"> 
|		
<#real	:	(<sign>)? <ureal> > 
|
<#ureal	:	<uinteger> | (<uinteger> "/" <uinteger>) | <decimal> >
|	
<#uinteger	:	(<digit>)+ ("#")* >
|
<#prefix	:	(<radix>)? (<exactness>)?
		|	(<exactness>)? (<radix>)?
		>
|		
<#decimal	:	<uinteger> <exponent>
			|	"." (<digit>)+ ("#")* (<exponent>)?
			|	(<digit>)+ "." (<digit>)* ("#")* (<exponent>)?
			|	(<digit>)+ ("#")+ "." ("#")* (<exponent>)?
			>
|		
<#exponent	:	<exponent_marker> (<sign>)? (<digit>)+ >
|
<#exponent_marker	: 	"e"
					| 	"s"
					|	"f"
					|	"d"
					|	"l"
					>
|					
<#sign	:	"+"|"-">
|		
<#exactness	:	"#i" |	"#e"			>
|
<#radix	: "#b" | "#o" | "#d" | "#x">
|
<#digit	:	["0"-"9"] | ["a"-"f"]>
		
}

GRAMMARSTART

/* Grammar taken from: http://www.cs.indiana.edu/scheme-repository/R4RS/r4rs_9.html */

@FSTNonTerminal
program : (command_or_definition)*;

@FSTNonTerminal
command_or_definition : LL("command()") command | definition;

@FSTNonTerminal
definition	: 
			  LL(2) "(" "begin" (definition)* ")"
			| LL(3) "(" "define" "(" variable [def_formals] ")" body ")" 
			| "(" "define" variable expression ")"; 

def_formals : (variable)+ ["." variable];

@FSTNonTerminal
command : expression;

datum : simple_datum | compound_datum;

simple_datum : <bool> | <number> | <character> | <string> |  symbol;

symbol : <identifier>;

compound_datum : list | vector;

list : LL(2) "(" ")"<NONE> | "(" (datum)+ ["." datum] ")" | abbreviation;

abbreviation : abbrev_prefix datum;

abbrev_prefix : "'" | "`" | "," | ",@";

vector : "#(" (datum)* ")";

@FSTNonTerminal
expression	: variable
			| LL(2) literal
			| LL(2) lambda_expression
			| LL(2) conditional
			| LL(2) assignment
			| LL(2) derived_expression
			| procedure_call
			;

literal : quotation | self_evaluating;

variable: <identifier>;

self_evaluating : <bool> | <number> | <character> | <string>;
     
quotation : "'" datum | LL(2) "(" "quote" datum ")";

procedure_call : LL(3) "(" operator ")" | "(" operator (operand)+ ")";

operator : expression;

operand : expression;

lambda_expression : "(" "lambda" formals body ")";

formals : variable | LL(2) "(" ")"<NONE> | "(" (variable)+ ["." variable] ")";

body : (LL(2) definition)* sequence;

sequence : (expression)+;

conditional : "(" "if" test consequent alternate ")";

test : expression;

consequent : expression;

alternate : expression | <NONE>;

assignment : "(" "set!" variable expression ")";

derived_expression	: LL(4) "(" "cond" "(" "else" sequence ")" ")"
					| LL(2) "(" "cond" (LL(2) cond_clause)+ ["(" "else" sequence ")"] ")"
					| LL(2) "(" "case" expression case_end ")"
					| LL(2) "(" "and" (test)* ")"
					| LL(2) "(" "or" (test)* ")"
					| LL(3) "(" "let" variable "(" (binding_spec)* ")" body ")"
					| LL(3) "(" "let" "(" (binding_spec)* ")" body ")"
					| LL("complex_let()") complex_let
					| LL(2) "(" "letrec" "(" (binding_spec)* ")" body ")"
					| LL(2) "(" "begin" sequence ")"
 					| LL(2) "(" "do" "(" (iteration_spec)* ")" "(" test sequence ")" (command)* ")"
					| LL(2) "(" "delay" expression ")"
//					| quasiquotation
					;
					
case_end: 	LL(2) "(" "else" sequence ")" | (LL(2) case_clause)+ ["(" "else" sequence ")"];				
complex_let: "(" (<let>)* "(" (binding_spec)* ")" body ")";

cond_clause : "(" test [cond_end] ")";
cond_end: "=>" recipient | sequence; 

recipient : expression;

case_clause : "(" "(" (datum)* ")" sequence ")";

binding_spec : "(" variable expression ")";

iteration_spec : "(" variable init [step] ")";

init : expression;

step : expression;
